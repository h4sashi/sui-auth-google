// server.js - Enhanced with browser wallet redirect support
import express from "express";
import bodyParser from "body-parser";
import fetch from "node-fetch";
import { jwtDecode } from "jwt-decode";
import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
import { isValidSuiAddress } from "@mysten/sui/utils";
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

import supabase from "./supabaseClient.js";

const app = express();

// Network Configuration
const NETWORK_CONFIG = {
  current: process.env.SUI_NETWORK || 'testnet',
  devnet: 'https://fullnode.devnet.sui.io',
  testnet: 'https://fullnode.testnet.sui.io', 
  mainnet: 'https://fullnode.mainnet.sui.io'
};

// Initialize Sui Client
const suiClient = new SuiClient({ 
  url: getFullnodeUrl(NETWORK_CONFIG.current) 
});

console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);

// CORS middleware
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

app.use(bodyParser.json());

// Add request logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('Request Body:', JSON.stringify(req.body, null, 2));
  }
  next();
});

const PORT = process.env.PORT || 3000;
const sessions = {}; // { state: profile }

// Helper function to check if user needs username setup
function needsUsernameSetup(profile) {
  if (!profile || !profile.name) return true;
  const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
  return isAutoGenerated;
}


// Replace the wallet-connect route with this simplified, working version
app.get("/wallet-connect", (req, res) => {
  const { state } = req.query;
  
  if (!state) {
    return res.status(400).send("Missing state parameter");
  }

  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Connect Your Sui Wallet</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                font-family: Arial, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                margin: 0;
                padding: 20px;
                min-height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .container {
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                max-width: 500px;
                width: 100%;
            }
            .title { color: #333; font-size: 24px; margin-bottom: 20px; text-align: center; }
            .status { padding: 15px; border-radius: 8px; margin: 15px 0; text-align: center; font-weight: bold; }
            .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
            .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
            .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
            .section { margin: 25px 0; padding: 20px; border: 2px solid #e9ecef; border-radius: 10px; }
            .wallet-item { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .wallet-detected { border-color: #28a745; background: #f8fff9; }
            .button {
                padding: 12px 20px;
                border: none;
                border-radius: 6px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s;
            }
            .button-primary { background: #007bff; color: white; }
            .button-primary:hover:not(:disabled) { background: #0056b3; }
            .button-success { background: #28a745; color: white; }
            .button-success:hover:not(:disabled) { background: #1e7e34; }
            .button:disabled { background: #6c757d; cursor: not-allowed; opacity: 0.6; }
            .input { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; margin: 10px 0; box-sizing: border-box; }
            .input:focus { border-color: #007bff; outline: none; }
            .loading { display: none; text-align: center; margin: 20px 0; }
            .spinner { border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto; }
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="title">Connect Your Sui Wallet</div>
            
            <div id="status" class="status info">Checking for wallet extensions...</div>
            
            <!-- Browser Wallet Section -->
            <div class="section">
                <h3>Browser Wallet Extensions</h3>
                <div id="wallet-list">
                    <div class="wallet-item" id="sui-wallet-item">
                        <div>
                            <strong>Sui Wallet</strong>
                            <div id="sui-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="sui-connect" onclick="connectBrowserWallet('sui')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="suiet-item">
                        <div>
                            <strong>Suiet</strong>
                            <div id="suiet-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="suiet-connect" onclick="connectBrowserWallet('suiet')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="ethos-item">
                        <div>
                            <strong>Ethos</strong>
                            <div id="ethos-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="ethos-connect" onclick="connectBrowserWallet('ethos')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="slush-item">
                        <div>
                            <strong>Slush</strong>
                            <div id="slush-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="slush-connect" onclick="connectBrowserWallet('slush')" disabled>Connect</button>
                    </div>
                </div>
            </div>
            
            <!-- Manual Connection Section -->
            <div class="section">
                <h3>Manual Connection</h3>
                <p>Enter your Sui wallet address directly:</p>
                <input type="text" 
                       class="input" 
                       id="manual-address" 
                       placeholder="0x1234567890abcdef..."
                       oninput="validateManualInput()">
                <button class="button button-success" 
                        id="manual-connect" 
                        onclick="connectManualWallet()" 
                        disabled>Connect Manual Wallet</button>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing connection...</p>
            </div>
        </div>

        <script>
            const STATE = '${state}';
            let walletCheckComplete = false;
            
            // Simplified wallet detection
            function checkWallets() {
                console.log('Starting wallet detection...');
                
                const wallets = {
                    'sui': {
                        check: function() { 
                            return window.suiWallet || window.sui; 
                        },
                        statusEl: 'sui-status',
                        connectEl: 'sui-connect',
                        itemEl: 'sui-wallet-item'
                    },
                    'suiet': {
                        check: function() { 
                            return window.suiet; 
                        },
                        statusEl: 'suiet-status',
                        connectEl: 'suiet-connect',
                        itemEl: 'suiet-item'
                    },
                    'ethos': {
                        check: function() { 
                            return window.ethos; 
                        },
                        statusEl: 'ethos-status',
                        connectEl: 'ethos-connect',
                        itemEl: 'ethos-item'
                    },
                    'slush': {
                        check: function() { 
                            return window.slush || window.slushWallet; 
                        },
                        statusEl: 'slush-status',
                        connectEl: 'slush-connect',
                        itemEl: 'slush-item'
                    }
                };
                
                let detectedCount = 0;
                
                for (const walletId in wallets) {
                    const wallet = wallets[walletId];
                    const statusEl = document.getElementById(wallet.statusEl);
                    const connectEl = document.getElementById(wallet.connectEl);
                    const itemEl = document.getElementById(wallet.itemEl);
                    
                    try {
                        const detected = wallet.check();
                        console.log('Wallet ' + walletId + ':', detected ? 'DETECTED' : 'not found');
                        
                        if (detected) {
                            statusEl.textContent = 'Detected';
                            statusEl.style.color = '#28a745';
                            connectEl.disabled = false;
                            itemEl.classList.add('wallet-detected');
                            detectedCount++;
                        } else {
                            statusEl.textContent = 'Not installed';
                            statusEl.style.color = '#6c757d';
                            connectEl.disabled = true;
                        }
                    } catch (error) {
                        console.error('Error checking ' + walletId + ':', error);
                        statusEl.textContent = 'Check failed';
                        statusEl.style.color = '#dc3545';
                        connectEl.disabled = true;
                    }
                }
                
                walletCheckComplete = true;
                updateStatus(detectedCount > 0 ? 
                    detectedCount + ' wallet(s) detected. Choose one to connect.' : 
                    'No browser wallets detected. Use manual connection below.', 
                    detectedCount > 0 ? 'success' : 'info');
                
                console.log('Wallet detection complete. Found:', detectedCount);
            }
            
            // Connect browser wallet
            async function connectBrowserWallet(walletType) {
                console.log('Attempting to connect browser wallet:', walletType);
                showLoading(true);
                
                try {
                    let wallet;
                    switch(walletType) {
                        case 'sui':
                            wallet = window.suiWallet || window.sui;
                            break;
                        case 'suiet':
                            wallet = window.suiet;
                            break;
                        case 'ethos':
                            wallet = window.ethos;
                            break;
                        case 'slush':
                            wallet = window.slush || window.slushWallet;
                            break;
                    }
                    
                    if (!wallet) {
                        throw new Error('Wallet not found');
                    }
                    
                    updateStatus('Requesting wallet permission...', 'info');
                    
                    // Try to connect
                    let accounts;
                    if (wallet.connect) {
                        const result = await wallet.connect();
                        accounts = result.accounts || result;
                    } else if (wallet.requestPermissions) {
                        const result = await wallet.requestPermissions();
                        accounts = result.accounts || result;
                    } else {
                        throw new Error('Wallet does not support connection');
                    }
                    
                    if (!accounts || !accounts.length) {
                        throw new Error('No accounts found');
                    }
                    
                    const address = accounts[0].address;
                    console.log('Got wallet address:', address);
                    
                    await submitWalletConnection({
                        walletAddress: address,
                        walletName: walletType,
                        signature: '',
                        message: '',
                        state: STATE
                    });
                    
                } catch (error) {
                    console.error('Browser wallet connection failed:', error);
                    updateStatus('Connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Validate manual input
            function validateManualInput() {
                const address = document.getElementById('manual-address').value.trim();
                const button = document.getElementById('manual-connect');
                
                if (address.length >= 60 && address.startsWith('0x')) {
                    button.disabled = false;
                } else {
                    button.disabled = true;
                }
            }
            
            // Connect manual wallet
            async function connectManualWallet() {
                const address = document.getElementById('manual-address').value.trim();
                console.log('Attempting manual wallet connection:', address);
                
                showLoading(true);
                updateStatus('Connecting manual wallet...', 'info');
                
                try {
                    await submitWalletConnection({
                        walletAddress: address,
                        walletName: 'manual',
                        signature: '',
                        message: '',
                        state: STATE
                    });
                } catch (error) {
                    console.error('Manual wallet connection failed:', error);
                    updateStatus('Manual connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Submit connection to server
            async function submitWalletConnection(data) {
                console.log('Submitting wallet connection:', data);
                
                try {
                    const response = await fetch('/auth/browser-wallet', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    const responseText = await response.text();
                    console.log('Server response status:', response.status);
                    console.log('Server response:', responseText);
                    
                    if (!response.ok) {
                        throw new Error('Server error: ' + response.status + ' - ' + responseText);
                    }
                    
                    const result = JSON.parse(responseText);
                    
                    if (result.success) {
                        updateStatus('SUCCESS! Wallet connected. You can close this window.', 'success');
                        setTimeout(function() { 
                            try { window.close(); } catch(e) { console.log('Cannot auto-close window'); }
                        }, 2000);
                    } else {
                        throw new Error(result.error || 'Unknown error');
                    }
                    
                } catch (error) {
                    console.error('Submit connection error:', error);
                    throw error;
                }
            }
            
            // Helper functions
            function updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = 'status ' + type;
                console.log('Status:', type, '-', message);
            }
            
            function showLoading(show) {
                const loading = document.getElementById('loading');
                if (show) {
                    loading.style.display = 'block';
                    // Disable all buttons
                    const buttons = document.querySelectorAll('button');
                    for (let i = 0; i < buttons.length; i++) {
                        buttons[i].disabled = true;
                    }
                } else {
                    loading.style.display = 'none';
                    // Re-run wallet check to re-enable appropriate buttons
                    if (walletCheckComplete) {
                        checkWallets();
                        validateManualInput();
                    }
                }
            }
            
            // Initialize
            function init() {
                console.log('Initializing wallet connection page with state:', STATE);
                updateStatus('Checking for wallet extensions...', 'info');
                
                // Check immediately
                setTimeout(checkWallets, 500);
                
                // Also check after a longer delay for slow-loading extensions
                setTimeout(function() {
                    if (!walletCheckComplete) {
                        console.log('Running delayed wallet check...');
                        checkWallets();
                    }
                }, 3000);
            }
            
            // Start when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        </script>
    </body>
    </html>
  `);
});

// Fixed browser wallet authentication endpoint - using the same pattern as manual wallet
app.post("/auth/browser-wallet", async (req, res) => {
  console.log("üîó Browser wallet connection request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { 
      walletAddress, 
      signature, 
      message, 
      walletName, 
      state 
    } = req.body;
    
    // Basic validation
    if (!walletAddress) {
      console.log("‚ùå Missing wallet address");
      return res.status(400).json({
        success: false,
        error: "Missing wallet address"
      });
    }
    
    if (!state) {
      console.log("‚ùå Missing state parameter");
      return res.status(400).json({
        success: false,
        error: "Missing state parameter"
      });
    }
    
    // Validate Sui address format
    if (!isValidSuiAddress(walletAddress)) {
      console.log("‚ùå Invalid address format:", walletAddress);
      return res.status(400).json({
        success: false,
        error: "Invalid Sui address format"
      });
    }
    
    console.log(`‚úÖ Valid wallet address: ${walletAddress}`);
    console.log(`üîó Browser wallet connecting: ${walletName || 'Unknown'} - ${walletAddress}`);
    
    // Check blockchain status
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      network: NETWORK_CONFIG.current,
      error: null
    };
    
    try {
      console.log('üîó Checking blockchain status...');
      
      const balance = await suiClient.getBalance({
        owner: walletAddress,
        coinType: '0x2::sui::SUI'
      });
      
      const objects = await suiClient.getOwnedObjects({
        owner: walletAddress,
        limit: 1
      });
      
      blockchainInfo = {
        exists: true,
        balance: balance.totalBalance,
        balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
        hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
        network: NETWORK_CONFIG.current
      };
      
      console.log(`‚úÖ Blockchain verified:`, blockchainInfo);
      
    } catch (blockchainError) {
      console.log(`‚ö†Ô∏è Blockchain check failed: ${blockchainError.message}`);
      blockchainInfo.error = blockchainError.message;
    }
    
    // Check if user already exists - using same pattern as manual wallet
    let { data: existingProfile, error: queryError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("sui_address", walletAddress)
      .single();
    
    if (queryError && queryError.code !== 'PGRST116') { // PGRST116 is "not found"
      console.error("‚ùå Database query error:", queryError);
      return res.status(500).json({ 
        success: false,
        error: "Database query failed" 
      });
    }
    
    let finalProfile;
    let isNewUser = false;
    
    if (existingProfile) {
      console.log("‚úÖ Found existing user profile:", existingProfile.id);
      
      // Update existing profile - using simple approach like manual wallet
      const { data: updated, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet'
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("‚ùå Profile update error:", updateError);
        return res.status(500).json({ 
          success: false,
          error: "Profile update failed" 
        });
      }
      
      finalProfile = updated;
      console.log("‚úÖ Existing user profile updated");
    } else {
      console.log("üÜï Creating new user profile");
      
      const tempName = `Player_${walletAddress.substring(0, 8)}`;
      
      // Use the same profile data structure as manual wallet (which works)
      const profileData = {
        email: null,
        google_id: null,
        name: tempName,
        picture: null,
        user_salt: null,
        sui_address: walletAddress,
        auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: inserted, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("‚ùå Profile insert error:", insertError);
        return res.status(500).json({ 
          success: false,
          error: "Profile creation failed: " + insertError.message 
        });
      }
      
      finalProfile = inserted;
      isNewUser = true;
      console.log("‚úÖ New user profile created:", finalProfile.id);
    }
    
    const needsUsername = needsUsernameSetup(finalProfile);
    console.log(`Username setup needed: ${needsUsername}`);
    
    // Create session for Unity polling - using same format as manual wallet
    const sessionData = {
      id: finalProfile.id,
      email: finalProfile.email,
      name: finalProfile.name,
      picture: finalProfile.picture,
      suiWallet: walletAddress,
      authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
      profileId: finalProfile.id,
      needsUsernameSetup: needsUsername
    };
    
    // Store session for Unity polling
    sessions[state] = sessionData;
    console.log("‚úÖ Session stored with state:", state);
    console.log("Session data:", JSON.stringify(sessionData, null, 2));
    
    // Use same response format as manual wallet (which works)
    const responseData = {
      success: true,
      message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
      needsUsernameSetup: needsUsername,
      blockchain: {
        verified: blockchainInfo.exists,
        balance: blockchainInfo.balance,
        balanceFormatted: blockchainInfo.balanceFormatted,
        network: blockchainInfo.network,
        error: blockchainInfo.error
      },
      profile: {
        id: finalProfile.id,
        name: finalProfile.name,
        suiWallet: walletAddress,
        authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername
      }
    };
    
    console.log("‚úÖ Sending success response:", JSON.stringify(responseData, null, 2));
    res.json(responseData);
    
  } catch (err) {
    console.error("‚ùå Browser wallet connection error:", err);
    res.status(500).json({ 
      success: false,
      error: "Wallet connection failed: " + err.message 
    });
  }
});


// Enhanced wallet validation with better debugging
app.post("/validate-wallet", async (req, res) => {
  console.log("üîç Wallet validation request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { address } = req.body;
    
    if (!address) {
      console.log("‚ùå No address provided");
      return res.status(400).json({
        valid: false,
        address: null,
        message: "No wallet address provided"
      });
    }
    
    const cleanAddress = address.trim();
    console.log(`üîç Validating address: ${cleanAddress}`);
    
    const isValidFormat = isValidSuiAddress(cleanAddress);
    console.log(`Address format validation: ${isValidFormat}`);
    
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      error: null
    };
    
    if (isValidFormat) {
      try {
        console.log('üîó Checking blockchain status...');
        
        const balance = await suiClient.getBalance({
          owner: cleanAddress,
          coinType: '0x2::sui::SUI'
        });
        
        const objects = await suiClient.getOwnedObjects({
          owner: cleanAddress,
          limit: 1
        });
        
        blockchainInfo = {
          exists: true,
          balance: balance.totalBalance,
          balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
          hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
          network: NETWORK_CONFIG.current
        };
        
        console.log(`‚úÖ Blockchain info:`, blockchainInfo);
        
      } catch (blockchainError) {
        console.log(`‚ö†Ô∏è Blockchain check failed: ${blockchainError.message}`);
        blockchainInfo.error = blockchainError.message;
        // Still valid format, just not active on blockchain yet
      }
    }
    
    const responseData = {
      valid: isValidFormat,
      address: cleanAddress,
      message: isValidFormat 
        ? (blockchainInfo.exists 
           ? `Valid Sui address (Balance: ${blockchainInfo.balanceFormatted})` 
           : 'Valid Sui address (Not yet active on blockchain)')
        : "Invalid Sui address format",
      blockchain: blockchainInfo,
      network: NETWORK_CONFIG.current
    };
    
    console.log("Sending validation response:", responseData);
    res.json(responseData);
    
  } catch (err) {
    console.error("Validation error:", err);
    res.status(500).json({
      valid: false,
      address: req.body?.address || null,
      message: "Server error during validation: " + err.message
    });
  }
});

// Username setup endpoint
app.post("/setup-username", async (req, res) => {
  const { walletAddress, username } = req.body;
  
  try {
    if (!walletAddress || !username) {
      return res.status(400).json({
        success: false,
        error: "Wallet address and username are required"
      });
    }
    
    const trimmedUsername = username.trim();
    
    if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
      return res.status(400).json({
        success: false,
        error: "Username must be between 3 and 20 characters"
      });
    }
    
    if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
      return res.status(400).json({
        success: false,
        error: "Username can only contain letters, numbers, underscore, and hyphen"
      });
    }
    
    const { data: existingUser, error: checkError } = await supabase
      .from("user_profiles")
      .select("id")
      .eq("name", trimmedUsername)
      .neq("sui_address", walletAddress)
      .single();
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: "Username already taken"
      });
    }
    
    const { data: updatedProfile, error: updateError } = await supabase
      .from("user_profiles")
      .update({ 
        name: trimmedUsername,
        updated_at: new Date().toISOString()
      })
      .eq("sui_address", walletAddress)
      .select()
      .single();
      
    if (updateError) {
      console.error("Username update error:", updateError);
      return res.status(500).json({
        success: false,
        error: "Failed to update username"
      });
    }
    
    res.json({
      success: true,
      message: "Username updated successfully",
      profile: {
        id: updatedProfile.id,
        name: updatedProfile.name,
        suiWallet: updatedProfile.sui_address,
        authMethod: updatedProfile.auth_method,
        profileId: updatedProfile.id,
        needsUsernameSetup: false
      }
    });
    
  } catch (err) {
    console.error("Username setup error:", err);
    res.status(500).json({
      success: false,
      error: "Username setup failed: " + err.message
    });
  }
});

// Google OAuth callback (unchanged)
app.get("/auth/google/callback", async (req, res) => {
  const { code, state } = req.query;
  
  if (!code) {
    console.error("No authorization code received");
    return res.status(400).send("Authorization failed - no code");
  }
  
  try {
    console.log("Processing Google OAuth callback...");
    
    const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        code,
        client_id: process.env.GOOGLE_CLIENT_ID,
        client_secret: process.env.GOOGLE_CLIENT_SECRET,
        redirect_uri: process.env.REDIRECT_URI,
        grant_type: "authorization_code"
      })
    });
    
    const tokens = await tokenResponse.json();
    
    if (!tokens.id_token) {
      throw new Error("No ID token received");
    }
    
    const userInfo = jwtDecode(tokens.id_token);
    console.log("User info:", { 
      sub: userInfo.sub, 
      email: userInfo.email, 
      name: userInfo.name 
    });
    
    let profile;
    let isNewUser = false;
    
    const { data: existingProfile, error: fetchError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("google_id", userInfo.sub)
      .single();
    
    if (existingProfile) {
      console.log("Existing zkLogin user found - updating login time");
      
      const { data: updatedProfile, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          name: userInfo.name,
          picture: userInfo.picture
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("Profile update error:", updateError);
        throw new Error("Profile update failed");
      }
      
      profile = updatedProfile;
      console.log(`Retrieved existing Sui address: ${profile.sui_address}`);
      
    } else {
      console.log("New zkLogin user - creating profile");
      
      const userSalt = generateRandomness();
      const suiAddress = jwtToAddress(tokens.id_token, userSalt);
      
      console.log("Generated new Sui address:", suiAddress);
      
      const profileData = {
        email: userInfo.email,
        google_id: userInfo.sub,
        name: userInfo.name,
        picture: userInfo.picture,
        user_salt: userSalt,
        sui_address: suiAddress,
        auth_method: "zklogin",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: insertedProfile, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("Profile insert error:", insertError);
        throw new Error("Profile creation failed");
      }
      
      profile = insertedProfile;
      isNewUser = true;
    }
    
    const needsUsername = needsUsernameSetup(profile);
    
    sessions[state] = {
      id: userInfo.sub,
      email: userInfo.email,
      name: profile.name,
      picture: userInfo.picture,
      suiWallet: profile.sui_address,
      authMethod: "zklogin",
      profileId: profile.id,
      sub: userInfo.sub,
      aud: userInfo.aud,
      needsUsernameSetup: needsUsername
    };
    
    try {
      console.log(`Checking Sui balance for zkLogin user...`);
      
      const balance = await suiClient.getBalance({
        owner: profile.sui_address,
        coinType: '0x2::sui::SUI'
      });
      
      const formattedBalance = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4);
      console.log(`Sui Balance: ${formattedBalance} SUI (${balance.totalBalance} MIST)`);
      
    } catch (balanceError) {
      console.log(`Could not fetch balance: ${balanceError.message} (This is normal for new addresses)`);
    }
    
    console.log(`zkLogin successful for ${userInfo.email} - ${isNewUser ? 'New user created' : 'Existing user logged in'}`);
    
    const welcomeMessage = isNewUser ? 
      `Welcome to the game, ${userInfo.name}!` : 
      `Welcome back, ${userInfo.name}!`;
    
    res.send(`
      <html>
        <head>
          <title>Sign In Successful</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
            .container { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; max-width: 500px; margin: 0 auto; }
            .success { color: #4CAF50; font-size: 28px; margin-bottom: 20px; }
            .info { color: #f0f0f0; margin: 15px 0; font-size: 16px; }
            .wallet { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; word-break: break-all; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="success">Sign In Successful!</div>
            <div class="info">${welcomeMessage}</div>
            <div class="info">Your Sui Wallet:</div>
            <div class="wallet">${profile.sui_address}</div>
            <div class="info" style="margin-top: 20px;">You can now close this window and return to the game.</div>
          </div>
        </body>
      </html>
    `);
    
  } catch (err) {
    console.error("OAuth callback error:", err);
    res.status(500).send(`
      <html>
        <head>
          <title>Authentication Failed</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f44336; color: white; }
          </style>
        </head>
        <body>
          <h1>Authentication Failed</h1>
          <p>Error: ${err.message}</p>
          <p>Please close this window and try again.</p>
        </body>
      </html>
    `);
  }
});

// Unity polling endpoint
app.get("/getProfile", (req, res) => {
  const { state } = req.query;
  if (sessions[state]) {
    res.json(sessions[state]);
    delete sessions[state];
  } else {
    res.status(404).send("Not ready");
  }
});

// Health check
app.get("/ping", async (req, res) => {
  try {
    const chainId = await suiClient.getChainIdentifier();
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      network: NETWORK_CONFIG.current,
      chainId
    });
  } catch (err) {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      networkError: err.message
    });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
  console.log(`RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
});
























// // server.js - Enhanced with network configuration and Sui SDK
// import express from "express";
// import bodyParser from "body-parser";
// import fetch from "node-fetch";
// import { jwtDecode } from "jwt-decode";
// import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
// import { isValidSuiAddress } from "@mysten/sui/utils";

// // Updated Sui SDK imports - Fixed for current version
// import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
// import { Transaction } from '@mysten/sui/transactions'; // Changed from TransactionBlock
// import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

// import supabase from "./supabaseClient.js";

// const app = express();

// // Network Configuration
// const NETWORK_CONFIG = {
//   // Choose your network here:
//   current: process.env.SUI_NETWORK || 'test', // 'devnet', 'testnet', or 'mainnet'
  
//   // Network URLs (automatically handled by getFullnodeUrl)
//   devnet: 'https://fullnode.devnet.sui.io',
//   testnet: 'https://fullnode.testnet.sui.io', 
//   mainnet: 'https://fullnode.mainnet.sui.io'
// };

// // Initialize Sui Client
// const suiClient = new SuiClient({ 
//   url: getFullnodeUrl(NETWORK_CONFIG.current) 
// });

// console.log(`üåê Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);
// console.log(`üîó RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);

// // CORS middleware
// app.use((req, res, next) => {
//   res.header('Access-Control-Allow-Origin', '*');
//   res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
//   res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
//   if (req.method === 'OPTIONS') {
//     res.sendStatus(200);
//   } else {
//     next();
//   }
// });

// app.use(bodyParser.json());

// // Add request logging middleware
// app.use((req, res, next) => {
//   console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
//   if (req.body && Object.keys(req.body).length > 0) {
//     console.log('Request Body:', JSON.stringify(req.body, null, 2));
//   }
//   next();
// });

// const PORT = process.env.PORT || 3000;
// const sessions = {}; // { state: profile }

// // Helper function to get network info
// async function getNetworkInfo() {
//   try {
//     const chainId = await suiClient.getChainIdentifier();
//     const latestCheckpoint = await suiClient.getLatestCheckpointSequenceNumber();
    
//     return {
//       network: NETWORK_CONFIG.current,
//       chainId,
//       latestCheckpoint: latestCheckpoint.toString(),
//       rpcUrl: getFullnodeUrl(NETWORK_CONFIG.current)
//     };
//   } catch (error) {
//     console.error('Failed to get network info:', error);
//     return {
//       network: NETWORK_CONFIG.current,
//       error: error.message,
//       rpcUrl: getFullnodeUrl(NETWORK_CONFIG.current)
//     };
//   }
// }

// // Helper function to check if user needs username setup
// function needsUsernameSetup(profile) {
//   if (!profile || !profile.name) return true;
//   const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
//   return isAutoGenerated;
// }

// // Network status endpoint
// app.get("/network/status", async (req, res) => {
//   try {
//     const networkInfo = await getNetworkInfo();
    
//     res.json({
//       ...networkInfo,
//       timestamp: new Date().toISOString(),
//       supportedNetworks: ['devnet', 'testnet', 'mainnet']
//     });
//   } catch (err) {
//     console.error("Network status error:", err);
//     res.status(500).json({ 
//       error: "Failed to get network status",
//       message: err.message 
//     });
//   }
// });

// // Enhanced wallet validation with blockchain verification
// app.post("/validate-wallet", async (req, res) => {
//   console.log("üîç Wallet validation request received");
  
//   try {
//     const { address } = req.body;
    
//     if (!address) {
//       return res.status(400).json({
//         valid: false,
//         address: null,
//         message: "No wallet address provided"
//       });
//     }
    
//     const cleanAddress = address.trim();
//     console.log(`üîç Validating address: ${cleanAddress}`);
    
//     // Format validation
//     const isValidFormat = isValidSuiAddress(cleanAddress);
    
//     let blockchainInfo = {
//       exists: false,
//       balance: '0',
//       hasActivity: false,
//       error: null
//     };
    
//     // If format is valid, check blockchain
//     if (isValidFormat) {
//       try {
//         console.log('üîó Checking blockchain status...');
        
//         // Check balance
//         const balance = await suiClient.getBalance({
//           owner: cleanAddress,
//           coinType: '0x2::sui::SUI'
//         });
        
//         // Check for any owned objects
//         const objects = await suiClient.getOwnedObjects({
//           owner: cleanAddress,
//           limit: 1
//         });
        
//         blockchainInfo = {
//           exists: true,
//           balance: balance.totalBalance,
//           balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
//           hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
//           network: NETWORK_CONFIG.current
//         };
        
//         console.log(`‚úÖ Blockchain info:`, blockchainInfo);
        
//       } catch (blockchainError) {
//         console.log(`‚ö†Ô∏è Blockchain check failed: ${blockchainError.message}`);
//         blockchainInfo.error = blockchainError.message;
//         // Note: This is normal for new addresses that haven't been used yet
//       }
//     }
    
//     const responseData = {
//       valid: isValidFormat,
//       address: cleanAddress,
//       message: isValidFormat 
//         ? `Valid Sui address${blockchainInfo.exists ? ` (Balance: ${blockchainInfo.balanceFormatted})` : ' (Not yet active on blockchain)'}` 
//         : "Invalid Sui address format",
//       blockchain: blockchainInfo,
//       network: NETWORK_CONFIG.current
//     };
    
//     console.log("üì§ Sending response:", responseData);
//     res.json(responseData);
    
//   } catch (err) {
//     console.error("‚ùå Validation error:", err);
//     res.status(500).json({
//       valid: false,
//       address: req.body?.address || null,
//       message: "Server error during validation: " + err.message
//     });
//   }
// });

// // Get detailed wallet information
// app.get("/wallet/:address/info", async (req, res) => {
//   const { address } = req.params;
  
//   try {
//     if (!isValidSuiAddress(address)) {
//       return res.status(400).json({ error: "Invalid wallet address" });
//     }
    
//     console.log(`üîç Fetching wallet info for: ${address}`);
    
//     // Get balance for SUI
//     const suiBalance = await suiClient.getBalance({
//       owner: address,
//       coinType: '0x2::sui::SUI'
//     });
    
//     // Get all coin balances
//     const allBalances = await suiClient.getAllBalances({
//       owner: address
//     });
    
//     // Get owned objects (limited to 20 for performance)
//     const objects = await suiClient.getOwnedObjects({
//       owner: address,
//       limit: 20,
//       options: {
//         showType: true,
//         showContent: true
//       }
//     });
    
//     // Get recent transactions (limited to 10)
//     const transactions = await suiClient.queryTransactionBlocks({
//       filter: { FromAddress: address },
//       limit: 10,
//       order: 'descending'
//     });
    
//     // Analyze object types
//     const objectTypes = {};
//     objects.data.forEach(obj => {
//       if (obj.data?.type) {
//         const type = obj.data.type.split('::').pop() || obj.data.type;
//         objectTypes[type] = (objectTypes[type] || 0) + 1;
//       }
//     });
    
//     const walletInfo = {
//       address,
//       network: NETWORK_CONFIG.current,
//       balance: {
//         sui: {
//           amount: suiBalance.totalBalance,
//           formatted: (parseInt(suiBalance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI'
//         },
//         allCoins: allBalances
//       },
//       objects: {
//         total: objects.data.length,
//         types: objectTypes,
//         hasNFTs: Object.keys(objectTypes).some(type => !type.includes('Coin'))
//       },
//       activity: {
//         transactionCount: transactions.data.length,
//         recentTransactions: transactions.data.slice(0, 3).map(tx => ({
//           digest: tx.digest,
//           timestamp: tx.timestampMs ? new Date(parseInt(tx.timestampMs)).toISOString() : null
//         }))
//       },
//       status: {
//         isActive: parseInt(suiBalance.totalBalance) > 0 || objects.data.length > 0,
//         isEmpty: parseInt(suiBalance.totalBalance) === 0 && objects.data.length === 0
//       }
//     };
    
//     console.log(`‚úÖ Wallet info retrieved for ${address}`);
//     res.json(walletInfo);
    
//   } catch (err) {
//     console.error("Wallet info error:", err);
//     res.status(500).json({ 
//       error: "Failed to fetch wallet info",
//       message: err.message,
//       address 
//     });
//   }
// });

// // Enhanced manual wallet connection with blockchain verification
// app.post("/auth/wallet", async (req, res) => {
//   const { walletAddress, state } = req.body;
  
//   try {
//     // Validate format
//     if (!walletAddress || !isValidSuiAddress(walletAddress)) {
//       return res.status(400).json({ 
//         success: false,
//         error: "Invalid Sui wallet address format" 
//       });
//     }
    
//     console.log("‚úÖ Manual wallet connection:", { walletAddress });
    
//     // Optional blockchain verification
//     let blockchainStatus = null;
//     try {
//       const balance = await suiClient.getBalance({
//         owner: walletAddress,
//         coinType: '0x2::sui::SUI'
//       });
      
//       blockchainStatus = {
//         verified: true,
//         balance: balance.totalBalance,
//         network: NETWORK_CONFIG.current
//       };
      
//       console.log(`‚úÖ Wallet verified on ${NETWORK_CONFIG.current}: ${balance.totalBalance} MIST`);
      
//     } catch (blockchainError) {
//       console.log(`‚ö†Ô∏è Wallet not active on ${NETWORK_CONFIG.current}: ${blockchainError.message}`);
//       blockchainStatus = {
//         verified: false,
//         error: blockchainError.message,
//         network: NETWORK_CONFIG.current
//       };
//     }
    
//     // Continue with existing database logic
//     let { data: existingProfile, error } = await supabase
//       .from("user_profiles")
//       .select("*")
//       .eq("sui_address", walletAddress)
//       .single();
    
//     let finalProfile;
//     let isNewUser = false;
    
//     if (existingProfile) {
//       // Update existing profile
//       const { data: updated, error: updateError } = await supabase
//         .from("user_profiles")
//         .update({ 
//           updated_at: new Date().toISOString()
//         })
//         .eq("id", existingProfile.id)
//         .select()
//         .single();
        
//       if (updateError) {
//         console.error("Profile update error:", updateError);
//         return res.status(500).json({ 
//           success: false,
//           error: "Profile update failed" 
//         });
//       }
      
//       finalProfile = updated;
//       console.log("‚úÖ Existing wallet user logged in");
//     } else {
//       // Create new profile
//       const tempName = `Player_${walletAddress.substring(0, 8)}`;
      
//       const profileData = {
//         email: null,
//         google_id: null,
//         name: tempName,
//         picture: null,
//         user_salt: null,
//         sui_address: walletAddress,
//         auth_method: "manual_wallet",
//         created_at: new Date().toISOString(),
//         updated_at: new Date().toISOString()
//       };
      
//       const { data: inserted, error: insertError } = await supabase
//         .from("user_profiles")
//         .insert([profileData])
//         .select()
//         .single();
        
//       if (insertError) {
//         console.error("Profile insert error:", insertError);
//         return res.status(500).json({ 
//           success: false,
//           error: "Profile creation failed" 
//         });
//       }
      
//       finalProfile = inserted;
//       isNewUser = true;
//       console.log("‚úÖ New wallet user created");
//     }
    
//     const needsUsername = needsUsernameSetup(finalProfile);
    
//     // Store session for Unity polling
//     if (state) {
//       sessions[state] = {
//         id: walletAddress.substring(0, 16),
//         email: finalProfile.email,
//         name: finalProfile.name,
//         picture: finalProfile.picture,
//         suiWallet: walletAddress,
//         authMethod: "manual_wallet",
//         profileId: finalProfile.id,
//         needsUsernameSetup: needsUsername
//       };
//     }
    
//     res.json({
//       success: true,
//       message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
//       needsUsernameSetup: needsUsername,
//       blockchain: blockchainStatus,
//       profile: {
//         id: finalProfile.id,
//         name: finalProfile.name,
//         suiWallet: walletAddress,
//         authMethod: "manual_wallet",
//         profileId: finalProfile.id,
//         needsUsernameSetup: needsUsername
//       }
//     });
    
//   } catch (err) {
//     console.error("Manual wallet connection error:", err);
//     res.status(500).json({ 
//       success: false,
//       error: "Wallet connection failed: " + err.message 
//     });
//   }
// });

// // Username setup endpoint
// app.post("/setup-username", async (req, res) => {
//   const { walletAddress, username } = req.body;
  
//   try {
//     if (!walletAddress || !username) {
//       return res.status(400).json({
//         success: false,
//         error: "Wallet address and username are required"
//       });
//     }
    
//     const trimmedUsername = username.trim();
    
//     // Validate username
//     if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
//       return res.status(400).json({
//         success: false,
//         error: "Username must be between 3 and 20 characters"
//       });
//     }
    
//     if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
//       return res.status(400).json({
//         success: false,
//         error: "Username can only contain letters, numbers, underscore, and hyphen"
//       });
//     }
    
//     // Check if username already exists
//     const { data: existingUser, error: checkError } = await supabase
//       .from("user_profiles")
//       .select("id")
//       .eq("name", trimmedUsername)
//       .neq("sui_address", walletAddress)
//       .single();
    
//     if (existingUser) {
//       return res.status(400).json({
//         success: false,
//         error: "Username already taken"
//       });
//     }
    
//     // Update user profile
//     const { data: updatedProfile, error: updateError } = await supabase
//       .from("user_profiles")
//       .update({ 
//         name: trimmedUsername,
//         updated_at: new Date().toISOString()
//       })
//       .eq("sui_address", walletAddress)
//       .select()
//       .single();
      
//     if (updateError) {
//       console.error("Username update error:", updateError);
//       return res.status(500).json({
//         success: false,
//         error: "Failed to update username"
//       });
//     }
    
//     res.json({
//       success: true,
//       message: "Username updated successfully",
//       profile: {
//         id: updatedProfile.id,
//         name: updatedProfile.name,
//         suiWallet: updatedProfile.sui_address,
//         authMethod: updatedProfile.auth_method,
//         profileId: updatedProfile.id,
//         needsUsernameSetup: false
//       }
//     });
    
//   } catch (err) {
//     console.error("Username setup error:", err);
//     res.status(500).json({
//       success: false,
//       error: "Username setup failed: " + err.message
//     });
//   }
// });

// // Replace your existing Google OAuth callback handler with this fixed version

// // Google OAuth callback 
// app.get("/auth/google/callback", async (req, res) => {
//   const { code, state } = req.query;
  
//   if (!code) {
//     console.error("‚ùå No authorization code received");
//     return res.status(400).send("Authorization failed - no code");
//   }
  
//   try {
//     console.log("üîÑ Processing Google OAuth callback...");
    
//     // Exchange code for tokens
//     const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
//       method: "POST",
//       headers: { "Content-Type": "application/x-www-form-urlencoded" },
//       body: new URLSearchParams({
//         code,
//         client_id: process.env.GOOGLE_CLIENT_ID,
//         client_secret: process.env.GOOGLE_CLIENT_SECRET,
//         redirect_uri: process.env.REDIRECT_URI,
//         grant_type: "authorization_code"
//       })
//     });
    
//     const tokens = await tokenResponse.json();
    
//     if (!tokens.id_token) {
//       throw new Error("No ID token received");
//     }
    
//     // Decode JWT to get user info
//     const userInfo = jwtDecode(tokens.id_token);
//     console.log("üë§ User info:", { 
//       sub: userInfo.sub, 
//       email: userInfo.email, 
//       name: userInfo.name 
//     });
    
//     let profile;
//     let isNewUser = false;
    
//     // Check if user already exists
//     const { data: existingProfile, error: fetchError } = await supabase
//       .from("user_profiles")
//       .select("*")
//       .eq("google_id", userInfo.sub)
//       .single();
    
//     if (existingProfile) {
//       console.log("‚úÖ Existing zkLogin user found - updating login time");
      
//       // Update existing user's last login
//       const { data: updatedProfile, error: updateError } = await supabase
//         .from("user_profiles")
//         .update({ 
//           updated_at: new Date().toISOString(),
//           // Update name and picture in case they changed on Google
//           name: userInfo.name,
//           picture: userInfo.picture
//         })
//         .eq("id", existingProfile.id)
//         .select()
//         .single();
        
//       if (updateError) {
//         console.error("‚ùå Profile update error:", updateError);
//         throw new Error("Profile update failed");
//       }
      
//       profile = updatedProfile;
//       console.log(`üîê Retrieved existing Sui address: ${profile.sui_address}`);
      
//     } else {
//       console.log("üÜï New zkLogin user - creating profile");
      
//       // Generate Sui address using zkLogin for new users
//       const userSalt = generateRandomness();
//       const suiAddress = jwtToAddress(tokens.id_token, userSalt);
      
//       console.log("üîê Generated new Sui address:", suiAddress);
      
//       // Create new user profile
//       const profileData = {
//         email: userInfo.email,
//         google_id: userInfo.sub,
//         name: userInfo.name,
//         picture: userInfo.picture,
//         user_salt: userSalt,
//         sui_address: suiAddress,
//         auth_method: "zklogin",
//         created_at: new Date().toISOString(),
//         updated_at: new Date().toISOString()
//       };
      
//       const { data: insertedProfile, error: insertError } = await supabase
//         .from("user_profiles")
//         .insert([profileData])
//         .select()
//         .single();
        
//       if (insertError) {
//         console.error("‚ùå Profile insert error:", insertError);
//         throw new Error("Profile creation failed");
//       }
      
//       profile = insertedProfile;
//       isNewUser = true;
//     }
    
//     const needsUsername = needsUsernameSetup(profile);
    
//     // Store session for Unity to poll
//     sessions[state] = {
//       id: userInfo.sub,
//       email: userInfo.email,
//       name: profile.name,
//       picture: userInfo.picture,
//       suiWallet: profile.sui_address,
//       authMethod: "zklogin",
//       profileId: profile.id,
//       sub: userInfo.sub,
//       aud: userInfo.aud,
//       needsUsernameSetup: needsUsername
//     };
    
//     // Fetch and display wallet balance in logs
//     try {
//       console.log(`üí∞ Checking Sui balance for zkLogin user...`);
      
//       const balance = await suiClient.getBalance({
//         owner: profile.sui_address,
//         coinType: '0x2::sui::SUI'
//       });
      
//       const formattedBalance = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4);
//       console.log(`üí∞ Sui Balance: ${formattedBalance} SUI (${balance.totalBalance} MIST)`);
      
//       // Optional: Check for any owned objects
//       const objects = await suiClient.getOwnedObjects({
//         owner: profile.sui_address,
//         limit: 5
//       });
      
//       console.log(`üì¶ Owned Objects: ${objects.data.length} items`);
      
//     } catch (balanceError) {
//       console.log(`‚ö†Ô∏è Could not fetch balance: ${balanceError.message} (This is normal for new addresses)`);
//     }
    
//     console.log(`‚úÖ zkLogin successful for ${userInfo.email} - ${isNewUser ? 'New user created' : 'Existing user logged in'}`);
    
//     // Return success page with appropriate message
//     const welcomeMessage = isNewUser ? 
//       `Welcome to the game, ${userInfo.name}!` : 
//       `Welcome back, ${userInfo.name}!`;
    
//     res.send(`
//       <html>
//         <head>
//           <title>Sign In Successful</title>
//           <style>
//             body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
//             .container { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; max-width: 500px; margin: 0 auto; }
//             .success { color: #4CAF50; font-size: 28px; margin-bottom: 20px; }
//             .info { color: #f0f0f0; margin: 15px 0; font-size: 16px; }
//             .wallet { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; word-break: break-all; }
//           </style>
//         </head>
//         <body>
//           <div class="container">
//             <div class="success">‚úÖ Sign In Successful!</div>
//             <div class="info">${welcomeMessage}</div>
//             <div class="info">Your Sui Wallet:</div>
//             <div class="wallet">${profile.sui_address}</div>
//             <div class="info" style="margin-top: 20px;">You can now close this window and return to the game.</div>
//           </div>
//         </body>
//       </html>
//     `);
    
//   } catch (err) {
//     console.error("‚ùå OAuth callback error:", err);
//     res.status(500).send(`
//       <html>
//         <head>
//           <title>Authentication Failed</title>
//           <style>
//             body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f44336; color: white; }
//           </style>
//         </head>
//         <body>
//           <h1>‚ùå Authentication Failed</h1>
//           <p>Error: ${err.message}</p>
//           <p>Please close this window and try again.</p>
//         </body>
//       </html>
//     `);
//   }
// });

// // Unity polling endpoint
// app.get("/getProfile", (req, res) => {
//   const { state } = req.query;
//   if (sessions[state]) {
//     res.json(sessions[state]);
//     delete sessions[state];
//   } else {
//     res.status(404).send("Not ready");
//   }
// });

// // Enhanced health check with network info
// app.get("/ping", async (req, res) => {
//   try {
//     const networkInfo = await getNetworkInfo();
//     res.json({
//       status: "ok",
//       timestamp: new Date().toISOString(),
//       message: "Server is running",
//       network: networkInfo
//     });
//   } catch (err) {
//     res.json({
//       status: "ok",
//       timestamp: new Date().toISOString(),
//       message: "Server is running",
//       networkError: err.message
//     });
//   }
// });

// // Test endpoint with your specific address
// app.get("/test-validation", async (req, res) => {
//   const testAddress = "0x59435d7c7acd3a3d17c8701d9384b25fdafd7669307dea06a8a70c8bd3fb52d0";
  
//   try {
//     const isValid = isValidSuiAddress(testAddress);
//     let blockchainInfo = null;
    
//     if (isValid) {
//       try {
//         const balance = await suiClient.getBalance({
//           owner: testAddress,
//           coinType: '0x2::sui::SUI'
//         });
        
//         blockchainInfo = {
//           balance: balance.totalBalance,
//           formatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
//           network: NETWORK_CONFIG.current
//         };
//       } catch (err) {
//         blockchainInfo = { error: err.message };
//       }
//     }
    
//     res.json({
//       testAddress,
//       formatValid: isValid,
//       blockchain: blockchainInfo,
//       network: NETWORK_CONFIG.current,
//       message: `Test validation: ${isValid ? 'PASSED' : 'FAILED'}`,
//       serverTime: new Date().toISOString()
//     });
//   } catch (err) {
//     res.status(500).json({
//       error: "Test validation failed",
//       message: err.message
//     });
//   }
// });

// app.listen(PORT, () => {
//   console.log(`üöÄ Server running on port ${PORT}`);
//   console.log(`üåê Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
//   console.log(`üîó RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
// });
