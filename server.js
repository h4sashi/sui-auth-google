// server.js - Enhanced with browser wallet redirect support
import express from "express";
import bodyParser from "body-parser";
import fetch from "node-fetch";
import { jwtDecode } from "jwt-decode";
import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
import { isValidSuiAddress } from "@mysten/sui/utils";
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

import supabase from "./supabaseClient.js";

const app = express();

// Network Configuration
const NETWORK_CONFIG = {
  current: process.env.SUI_NETWORK || 'testnet',
  devnet: 'https://fullnode.devnet.sui.io',
  testnet: 'https://fullnode.testnet.sui.io', 
  mainnet: 'https://fullnode.mainnet.sui.io'
};

// Initialize Sui Client
const suiClient = new SuiClient({ 
  url: getFullnodeUrl(NETWORK_CONFIG.current) 
});

console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);

// CORS middleware
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

app.use(bodyParser.json());

// Add request logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('Request Body:', JSON.stringify(req.body, null, 2));
  }
  next();
});

const PORT = process.env.PORT || 3000;
const sessions = {}; // { state: profile }

// Helper function to check if user needs username setup
function needsUsernameSetup(profile) {
  if (!profile || !profile.name) return true;
  const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
  return isAutoGenerated;
}


// Replace the wallet-connect route in server.js with this fixed version
app.get("/wallet-connect", (req, res) => {
  const { state } = req.query;
  
  if (!state) {
    return res.status(400).send("Missing state parameter");
  }

  // Serve wallet connection HTML page with proper wallet detection
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Connect Your Sui Wallet</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                margin: 0;
                padding: 20px;
                min-height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .container {
                background: rgba(255,255,255,0.95);
                padding: 40px;
                border-radius: 20px;
                box-shadow: 0 20px 40px rgba(0,0,0,0.1);
                max-width: 500px;
                width: 100%;
                text-align: center;
            }
            .title {
                color: #333;
                font-size: 28px;
                margin-bottom: 10px;
                font-weight: 600;
            }
            .subtitle {
                color: #666;
                font-size: 16px;
                margin-bottom: 30px;
            }
            .wallet-button {
                display: block;
                width: 100%;
                padding: 16px 24px;
                margin: 12px 0;
                background: #4F46E5;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 16px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                text-decoration: none;
            }
            .wallet-button:hover:not(:disabled) {
                background: #4338CA;
                transform: translateY(-2px);
                box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
            }
            .wallet-button:disabled {
                background: #9CA3AF;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }
            .status {
                margin: 20px 0;
                padding: 12px;
                border-radius: 8px;
                font-weight: 500;
            }
            .status.success {
                background: #D1FAE5;
                color: #065F46;
                border: 1px solid #A7F3D0;
            }
            .status.error {
                background: #FEE2E2;
                color: #991B1B;
                border: 1px solid #FECACA;
            }
            .status.info {
                background: #EFF6FF;
                color: #1E40AF;
                border: 1px solid #DBEAFE;
            }
            .wallet-list {
                text-align: left;
                margin: 20px 0;
            }
            .wallet-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px;
                margin: 8px 0;
                border: 2px solid #E5E7EB;
                border-radius: 8px;
                transition: border-color 0.3s;
            }
            .wallet-item.detected {
                border-color: #10B981;
                background: #F0FDF4;
            }
            .wallet-name {
                font-weight: 500;
            }
            .wallet-status {
                font-size: 14px;
                color: #6B7280;
            }
            .detected {
                color: #10B981 !important;
            }
            .not-detected {
                color: #EF4444 !important;
            }
            .install-link {
                color: #4F46E5;
                text-decoration: none;
                font-size: 12px;
                margin-left: 8px;
            }
            .manual-option {
                margin-top: 30px;
                padding-top: 20px;
                border-top: 1px solid #E5E7EB;
            }
            .manual-option h3 {
                color: #374151;
                margin-bottom: 15px;
            }
            .address-input {
                width: 100%;
                padding: 12px;
                border: 2px solid #E5E7EB;
                border-radius: 8px;
                font-size: 14px;
                margin-bottom: 10px;
                box-sizing: border-box;
            }
            .address-input:focus {
                outline: none;
                border-color: #4F46E5;
            }
            .loading {
                display: none;
                margin: 20px 0;
            }
            .spinner {
                border: 3px solid #f3f3f3;
                border-top: 3px solid #4F46E5;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                animation: spin 1s linear infinite;
                margin: 0 auto;
            }
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="title">Connect Your Sui Wallet</div>
            <div class="subtitle">Choose how you'd like to connect to the game</div>
            
            <div id="status" class="status info">
                Checking for installed Sui wallets...
            </div>
            
            <div class="wallet-list" id="walletList">
                <div class="wallet-item" id="sui-wallet">
                    <div>
                        <div class="wallet-name">Sui Wallet</div>
                        <div class="wallet-status" id="sui-wallet-status">Checking...</div>
                    </div>
                    <button class="wallet-button" onclick="connectWallet('sui-wallet')" disabled>Connect</button>
                </div>
                
                <div class="wallet-item" id="suiet">
                    <div>
                        <div class="wallet-name">Suiet Wallet</div>
                        <div class="wallet-status" id="suiet-status">Checking...</div>
                    </div>
                    <button class="wallet-button" onclick="connectWallet('suiet')" disabled>Connect</button>
                </div>
                
                <div class="wallet-item" id="ethos">
                    <div>
                        <div class="wallet-name">Ethos Wallet</div>
                        <div class="wallet-status" id="ethos-status">Checking...</div>
                    </div>
                    <button class="wallet-button" onclick="connectWallet('ethos')" disabled>Connect</button>
                </div>
                
                <div class="wallet-item" id="slush">
                    <div>
                        <div class="wallet-name">Slush Wallet</div>
                        <div class="wallet-status" id="slush-status">Checking...</div>
                    </div>
                    <button class="wallet-button" onclick="connectWallet('slush')" disabled>Connect</button>
                </div>
            </div>
            
            <div class="manual-option">
                <h3>Or Connect Manually</h3>
                <input type="text" 
                       class="address-input" 
                       id="manualAddress" 
                       placeholder="Enter your Sui wallet address (0x...)"
                       onchange="validateManualAddress()">
                <button class="wallet-button" 
                        onclick="connectManualWallet()" 
                        id="manualConnectBtn" 
                        disabled>
                    Connect Manual Wallet
                </button>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Connecting wallet...</p>
            </div>
        </div>

        <script>
            const state = '${state}';
            let detectedWallets = {};
            
            // Comprehensive wallet detection with proper checks
            function checkWallets() {
                console.log('Checking for wallet extensions...');
                
                // Wait for DOM to fully load and extensions to initialize
                const walletChecks = {
                    'sui-wallet': () => {
                        return window.suiWallet || 
                               (window.sui && window.sui.wallet) ||
                               window.wallet ||
                               (window.chrome && window.chrome.sui);
                    },
                    'suiet': () => {
                        return window.suiet || window.suietWallet;
                    },
                    'ethos': () => {
                        return window.ethos || window.ethosWallet;
                    },
                    'slush': () => {
                        return window.slush || 
                               window.slushWallet || 
                               (window.sui && window.sui.slush);
                    }
                };
                
                let foundCount = 0;
                
                for (const [walletId, checkFunction] of Object.entries(walletChecks)) {
                    const statusEl = document.getElementById(walletId + '-status');
                    const buttonEl = document.querySelector('#' + walletId + ' button');
                    const itemEl = document.getElementById(walletId);
                    
                    try {
                        const wallet = checkFunction();
                        console.log('Checking ${walletId}:', wallet ? 'Found' : 'Not found');
                        
                        if (wallet && typeof wallet === 'object') {
                            statusEl.innerHTML = '<span class="detected">✓ Detected</span>';
                            statusEl.className = 'wallet-status detected';
                            buttonEl.disabled = false;
                            itemEl.classList.add('detected');
                            detectedWallets[walletId] = wallet;
                            foundCount++;
                            console.log('${walletId} detected and ready');
                        } else {
                            statusEl.innerHTML = '<span class="not-detected">Not installed</span> <a href="#" class="install-link" onclick="installWallet(\\''+walletId+'\\')">Install</a>';
                            buttonEl.disabled = true;
                            itemEl.classList.remove('detected');
                        }
                    } catch (error) {
                        console.error('Error checking ${walletId}:', error);
                        statusEl.innerHTML = '<span class="not-detected">Error checking</span>';
                        buttonEl.disabled = true;
                    }
                }
                
                const statusEl = document.getElementById('status');
                if (foundCount > 0) {
                    statusEl.textContent = foundCount + ' wallet(s) detected. Click Connect to proceed.';
                    statusEl.className = 'status success';
                } else {
                    statusEl.textContent = 'No Sui wallets detected. Install a wallet extension or connect manually below.';
                    statusEl.className = 'status error';
                }
                
                console.log('Total wallets detected: ${foundCount}');
            }
            
            // Connect to a specific wallet with better error handling
            async function connectWallet(walletName) {
                const wallet = detectedWallets[walletName];
                if (!wallet) {
                    updateStatus('Wallet not found: ' + walletName, 'error');
                    return;
                }
                
                showLoading(true);
                updateStatus('Requesting wallet connection...', 'info');
                
                try {
                    console.log('Attempting to connect to ${walletName}...');
                    
                    let connection;
                    
                    // Different wallets have different connection methods
                    if (wallet.connect) {
                        connection = await wallet.connect();
                    } else if (wallet.requestPermissions) {
                        connection = await wallet.requestPermissions();
                    } else {
                        throw new Error('Wallet does not support connection');
                    }
                    
                    console.log('Wallet connection result:', connection);
                    
                    if (connection && connection.accounts && connection.accounts.length > 0) {
                        const address = connection.accounts[0].address;
                        console.log('Got wallet address:', address);
                        
                        // Optional: Request signature for verification
                        let signature = '';
                        let message = 'Connect to Game - ' + new Date().toISOString();
                        
                        try {
                            if (wallet.signMessage || wallet.signPersonalMessage) {
                                const signMethod = wallet.signMessage || wallet.signPersonalMessage;
                                const signResult = await signMethod({
                                    message: new TextEncoder().encode(message),
                                    account: connection.accounts[0]
                                });
                                signature = signResult.signature || '';
                                console.log('Signature obtained');
                            }
                        } catch (sigError) {
                            console.warn('Signature failed, continuing without:', sigError);
                        }
                        
                        // Send to server
                        await submitWalletConnection({
                            walletAddress: address,
                            signature: signature,
                            message: message,
                            walletName: walletName,
                            state: state
                        });
                        
                    } else {
                        throw new Error('No accounts found in wallet connection');
                    }
                    
                } catch (error) {
                    console.error('Wallet connection failed:', error);
                    updateStatus('Connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Manual wallet connection with validation
            function validateManualAddress() {
                const address = document.getElementById('manualAddress').value.trim();
                const button = document.getElementById('manualConnectBtn');
                
                if (address.length >= 64 && address.startsWith('0x')) {
                    button.disabled = false;
                    button.textContent = 'Connect Manual Wallet';
                } else if (address.length > 0) {
                    button.disabled = true;
                    button.textContent = 'Invalid Address Format';
                } else {
                    button.disabled = true;
                    button.textContent = 'Connect Manual Wallet';
                }
            }
            
            async function connectManualWallet() {
                const address = document.getElementById('manualAddress').value.trim();
                if (!address) return;
                
                showLoading(true);
                updateStatus('Connecting manual wallet...', 'info');
                
                try {
                    await submitWalletConnection({
                        walletAddress: address,
                        signature: '',
                        message: '',
                        walletName: 'manual',
                        state: state
                    });
                } catch (error) {
                    updateStatus('Manual connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Submit wallet connection to server with better error handling
            async function submitWalletConnection(data) {
                try {
                    console.log('Submitting wallet connection:', data);
                    
                    const response = await fetch('/auth/browser-wallet', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });
                    
                    const responseText = await response.text();
                    console.log('Server response:', responseText);
                    
                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (parseError) {
                        throw new Error('Server returned invalid JSON: ' + responseText);
                    }
                    
                    if (result.success) {
                        updateStatus('Wallet connected successfully! You can now close this window.', 'success');
                        
                        // Auto-close after 3 seconds
                        setTimeout(() => {
                            window.close();
                        }, 3000);
                        
                    } else {
                        throw new Error(result.error || 'Connection failed');
                    }
                    
                } catch (error) {
                    console.error('Submit wallet connection error:', error);
                    throw error;
                }
            }
            
            // Helper functions
            function updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = 'status ' + type;
                console.log('Status update:', message, type);
            }
            
            function showLoading(show) {
                const loading = document.getElementById('loading');
                
                if (show) {
                    loading.style.display = 'block';
                    document.querySelectorAll('button').forEach(btn => btn.disabled = true);
                } else {
                    loading.style.display = 'none';
                    checkWallets(); // Re-enable appropriate buttons
                    validateManualAddress(); // Re-check manual input
                }
            }
            
            function installWallet(walletName) {
                const urls = {
                    'sui-wallet': 'https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil',
                    'suiet': 'https://chrome.google.com/webstore/detail/suiet-sui-wallet/khpkpbbcccdmmclmpigdgddabeilkdpd',
                    'ethos': 'https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli',
                    'slush': 'https://chrome.google.com/webstore/search/slush%20wallet'
                };
                
                if (urls[walletName]) {
                    window.open(urls[walletName], '_blank');
                }
            }
            
            // Enhanced initialization with multiple retry attempts
            function initializeWalletDetection() {
                console.log('Initializing wallet detection...');
                
                // Initial check after a delay to allow extensions to load
                setTimeout(() => {
                    checkWallets();
                }, 1000);
                
                // Retry detection periodically for newly installed extensions
                let retryCount = 0;
                const maxRetries = 15; // Increased retries
                
                const retryDetection = setInterval(() => {
                    console.log('Wallet detection retry ${retryCount + 1}/${maxRetries}');
                    checkWallets();
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        clearInterval(retryDetection);
                        console.log('Wallet detection completed');
                    }
                }, 2000);
            }
            
            // Start detection when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWalletDetection);
            } else {
                initializeWalletDetection();
            }
        </script>
    </body>
    </html>
  `);
});

// Fixed browser wallet authentication endpoint
app.post("/auth/browser-wallet", async (req, res) => {
  console.log("🔗 Browser wallet connection request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { 
      walletAddress, 
      signature, 
      message, 
      walletName, 
      state 
    } = req.body;
    
    // Basic validation
    if (!walletAddress) {
      console.log("❌ Missing wallet address");
      return res.status(400).json({
        success: false,
        error: "Missing wallet address"
      });
    }
    
    if (!state) {
      console.log("❌ Missing state parameter");
      return res.status(400).json({
        success: false,
        error: "Missing state parameter"
      });
    }
    
    // Validate Sui address format
    if (!isValidSuiAddress(walletAddress)) {
      console.log("❌ Invalid address format:", walletAddress);
      return res.status(400).json({
        success: false,
        error: "Invalid Sui address format"
      });
    }
    
    console.log('✅ Valid wallet address: ${walletAddress}');
    console.log(`🔗 Browser wallet connecting: ${walletName || 'Unknown'} - ${walletAddress}`);
    
    // Optional: Verify signature if provided
    let signatureVerified = false;
    if (signature && message) {
      try {
        // Here you would typically verify the signature
        // For now, we'll assume it's valid if provided
        signatureVerified = true;
        console.log("✅ Signature verification passed");
      } catch (sigError) {
        console.log("⚠️ Signature verification failed:", sigError.message);
      }
    }
    
    // Check blockchain status
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      network: NETWORK_CONFIG.current,
      error: null
    };
    
    try {
      console.log('🔗 Checking blockchain status...');
      
      const balance = await suiClient.getBalance({
        owner: walletAddress,
        coinType: '0x2::sui::SUI'
      });
      
      const objects = await suiClient.getOwnedObjects({
        owner: walletAddress,
        limit: 1
      });
      
      blockchainInfo = {
        exists: true,
        balance: balance.totalBalance,
        balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
        hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
        network: NETWORK_CONFIG.current
      };
      
      console.log(`✅ Blockchain verified:`, blockchainInfo);
      
    } catch (blockchainError) {
      console.log(`⚠️ Blockchain check failed: ${blockchainError.message}`);
      blockchainInfo.error = blockchainError.message;
    }
    
    // Check if user already exists
    let { data: existingProfile, error: queryError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("sui_address", walletAddress)
      .single();
    
    if (queryError && queryError.code !== 'PGRST116') { // PGRST116 is "not found"
      console.error("❌ Database query error:", queryError);
      return res.status(500).json({ 
        success: false,
        error: "Database query failed" 
      });
    }
    
    let finalProfile;
    let isNewUser = false;
    
    if (existingProfile) {
      console.log("✅ Found existing user profile:", existingProfile.id);
      
      // Update existing profile
      const { data: updated, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
          last_wallet_name: walletName !== 'manual' ? walletName : null,
          last_signature_verified: signatureVerified
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("❌ Profile update error:", updateError);
        return res.status(500).json({ 
          success: false,
          error: "Profile update failed" 
        });
      }
      
      finalProfile = updated;
      console.log("✅ Existing user profile updated");
    } else {
      console.log("🆕 Creating new user profile");
      
      const tempName = 'Player_${walletAddress.substring(0, 8)}';
      
      const profileData = {
        email: null,
        google_id: null,
        name: tempName,
        picture: null,
        user_salt: null,
        sui_address: walletAddress,
        auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        last_wallet_name: walletName !== 'manual' ? walletName : null,
        last_signature_verified: signatureVerified,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: inserted, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("❌ Profile insert error:", insertError);
        return res.status(500).json({ 
          success: false,
          error: "Profile creation failed: " + insertError.message 
        });
      }
      
      finalProfile = inserted;
      isNewUser = true;
      console.log("✅ New user profile created:", finalProfile.id);
    }
    
    const needsUsername = needsUsernameSetup(finalProfile);
    console.log(`Username setup needed: ${needsUsername}`);
    
    // Create session for Unity polling
    const sessionData = {
      id: finalProfile.id,
      email: finalProfile.email,
      name: finalProfile.name,
      picture: finalProfile.picture,
      suiWallet: walletAddress,
      authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
      profileId: finalProfile.id,
      needsUsernameSetup: needsUsername,
      walletName: walletName !== 'manual' ? walletName : null,
      signatureVerified: signatureVerified
    };
    
    // Store session for Unity polling
    sessions[state] = sessionData;
    console.log("✅ Session stored with state:", state);
    console.log("Session data:", JSON.stringify(sessionData, null, 2));
    
    const responseData = {
      success: true,
      message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
      needsUsernameSetup: needsUsername,
      blockchain: blockchainInfo,
      sessionState: state, // Return the session state so Unity can poll for it
      profile: {
        id: finalProfile.id,
        name: finalProfile.name,
        suiWallet: walletAddress,
        authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername,
        walletName: walletName !== 'manual' ? walletName : null,
        signatureVerified: signatureVerified
      }
    };
    
    console.log("✅ Sending success response:", JSON.stringify(responseData, null, 2));
    res.json(responseData);
    
  } catch (err) {
    console.error("❌ Browser wallet connection error:", err);
    res.status(500).json({ 
      success: false,
      error: "Wallet connection failed: " + err.message 
    });
  }
});

// Enhanced manual wallet connection with better error handling
app.post("/auth/wallet", async (req, res) => {
  console.log("🔗 Manual wallet connection request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { walletAddress, state } = req.body;
    
    if (!walletAddress) {
      console.log("❌ Missing wallet address");
      return res.status(400).json({ 
        success: false,
        error: "Missing wallet address" 
      });
    }
    
    if (!isValidSuiAddress(walletAddress)) {
      console.log("❌ Invalid address format:", walletAddress);
      return res.status(400).json({ 
        success: false,
        error: "Invalid Sui wallet address format" 
      });
    }
    
    console.log("✅ Manual wallet connection:", { walletAddress });
    
    // Check blockchain status
    let blockchainStatus = null;
    try {
      console.log('🔗 Checking blockchain status...');
      
      const balance = await suiClient.getBalance({
        owner: walletAddress,
        coinType: '0x2::sui::SUI'
      });
      
      blockchainStatus = {
        verified: true,
        balance: balance.totalBalance,
        balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
        network: NETWORK_CONFIG.current
      };
      
      console.log(`[OK] Wallet verified on ${NETWORK_CONFIG.current}: ${balance.totalBalance} MIST`);
      
    } catch (blockchainError) {
      console.log(`[WARN] Wallet not active on ${NETWORK_CONFIG.current}: ${blockchainError.message}`);
      blockchainStatus = {
        verified: false,
        error: blockchainError.message,
        network: NETWORK_CONFIG.current
      };
    }
    
    // Check for existing profile
    let { data: existingProfile, error: queryError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("sui_address", walletAddress)
      .single();
    
    if (queryError && queryError.code !== 'PGRST116') {
      console.error("❌ Database query error:", queryError);
      return res.status(500).json({ 
        success: false,
        error: "Database query failed" 
      });
    }
    
    let finalProfile;
    let isNewUser = false;
    
    if (existingProfile) {
      console.log("✅ Found existing manual wallet user");
      
      const { data: updated, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          auth_method: "manual_wallet"
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("❌ Profile update error:", updateError);
        return res.status(500).json({ 
          success: false,
          error: "Profile update failed" 
        });
      }
      
      finalProfile = updated;
      console.log("✅ Existing manual wallet user logged in");
    } else {
      console.log("🆕 Creating new manual wallet user");
      
      const tempName = `Player_${walletAddress.substring(0, 8)}`;
      
      const profileData = {
        email: null,
        google_id: null,
        name: tempName,
        picture: null,
        user_salt: null,
        sui_address: walletAddress,
        auth_method: "manual_wallet",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: inserted, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("❌ Profile insert error:", insertError);
        return res.status(500).json({ 
          success: false,
          error: "Profile creation failed: " + insertError.message 
        });
      }
      
      finalProfile = inserted;
      isNewUser = true;
      console.log("✅ New manual wallet user created");
    }
    
    const needsUsername = needsUsernameSetup(finalProfile);
    console.log(`Username setup needed: ${needsUsername}`);
    
    // Create session for Unity polling if state provided
    if (state) {
      const sessionData = {
        id: finalProfile.id,
        email: finalProfile.email,
        name: finalProfile.name,
        picture: finalProfile.picture,
        suiWallet: walletAddress,
        authMethod: "manual_wallet",
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername
      };
      
      sessions[state] = sessionData;
      console.log("✅ Session stored for Unity polling with state:", state);
    }
    
    const responseData = {
      success: true,
      message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
      needsUsernameSetup: needsUsername,
      blockchain: blockchainStatus,
      profile: {
        id: finalProfile.id,
        name: finalProfile.name,
        suiWallet: walletAddress,
        authMethod: "manual_wallet",
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername
      }
    };
    
    console.log("✅ Sending manual wallet success response:", JSON.stringify(responseData, null, 2));
    res.json(responseData);
    
  } catch (err) {
    console.error("❌ Manual wallet connection error:", err);
    res.status(500).json({ 
      success: false,
      error: "Wallet connection failed: " + err.message 
    });
  }
});

// Enhanced wallet validation with better debugging
app.post("/validate-wallet", async (req, res) => {
  console.log("🔍 Wallet validation request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { address } = req.body;
    
    if (!address) {
      console.log("❌ No address provided");
      return res.status(400).json({
        valid: false,
        address: null,
        message: "No wallet address provided"
      });
    }
    
    const cleanAddress = address.trim();
    console.log(`🔍 Validating address: ${cleanAddress}`);
    
    const isValidFormat = isValidSuiAddress(cleanAddress);
    console.log(`Address format validation: ${isValidFormat}`);
    
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      error: null
    };
    
    if (isValidFormat) {
      try {
        console.log('🔗 Checking blockchain status...');
        
        const balance = await suiClient.getBalance({
          owner: cleanAddress,
          coinType: '0x2::sui::SUI'
        });
        
        const objects = await suiClient.getOwnedObjects({
          owner: cleanAddress,
          limit: 1
        });
        
        blockchainInfo = {
          exists: true,
          balance: balance.totalBalance,
          balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
          hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
          network: NETWORK_CONFIG.current
        };
        
        console.log(`✅ Blockchain info:`, blockchainInfo);
        
      } catch (blockchainError) {
        console.log(`⚠️ Blockchain check failed: ${blockchainError.message}`);
        blockchainInfo.error = blockchainError.message;
        // Still valid format, just not active on blockchain yet
      }
    }
    
    const responseData = {
      valid: isValidFormat,
      address: cleanAddress,
      message: isValidFormat 
        ? (blockchainInfo.exists 
           ? `Valid Sui address (Balance: ${blockchainInfo.balanceFormatted})` 
           : 'Valid Sui address (Not yet active on blockchain)')
        : "Invalid Sui address format",
      blockchain: blockchainInfo,
      network: NETWORK_CONFIG.current
    };
    
    console.log("Sending validation response:", responseData);
    res.json(responseData);
    
  } catch (err) {
    console.error("Validation error:", err);
    res.status(500).json({
      valid: false,
      address: req.body?.address || null,
      message: "Server error during validation: " + err.message
    });
  }
});

// Username setup endpoint
app.post("/setup-username", async (req, res) => {
  const { walletAddress, username } = req.body;
  
  try {
    if (!walletAddress || !username) {
      return res.status(400).json({
        success: false,
        error: "Wallet address and username are required"
      });
    }
    
    const trimmedUsername = username.trim();
    
    if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
      return res.status(400).json({
        success: false,
        error: "Username must be between 3 and 20 characters"
      });
    }
    
    if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
      return res.status(400).json({
        success: false,
        error: "Username can only contain letters, numbers, underscore, and hyphen"
      });
    }
    
    const { data: existingUser, error: checkError } = await supabase
      .from("user_profiles")
      .select("id")
      .eq("name", trimmedUsername)
      .neq("sui_address", walletAddress)
      .single();
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: "Username already taken"
      });
    }
    
    const { data: updatedProfile, error: updateError } = await supabase
      .from("user_profiles")
      .update({ 
        name: trimmedUsername,
        updated_at: new Date().toISOString()
      })
      .eq("sui_address", walletAddress)
      .select()
      .single();
      
    if (updateError) {
      console.error("Username update error:", updateError);
      return res.status(500).json({
        success: false,
        error: "Failed to update username"
      });
    }
    
    res.json({
      success: true,
      message: "Username updated successfully",
      profile: {
        id: updatedProfile.id,
        name: updatedProfile.name,
        suiWallet: updatedProfile.sui_address,
        authMethod: updatedProfile.auth_method,
        profileId: updatedProfile.id,
        needsUsernameSetup: false
      }
    });
    
  } catch (err) {
    console.error("Username setup error:", err);
    res.status(500).json({
      success: false,
      error: "Username setup failed: " + err.message
    });
  }
});

// Google OAuth callback (unchanged)
app.get("/auth/google/callback", async (req, res) => {
  const { code, state } = req.query;
  
  if (!code) {
    console.error("No authorization code received");
    return res.status(400).send("Authorization failed - no code");
  }
  
  try {
    console.log("Processing Google OAuth callback...");
    
    const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        code,
        client_id: process.env.GOOGLE_CLIENT_ID,
        client_secret: process.env.GOOGLE_CLIENT_SECRET,
        redirect_uri: process.env.REDIRECT_URI,
        grant_type: "authorization_code"
      })
    });
    
    const tokens = await tokenResponse.json();
    
    if (!tokens.id_token) {
      throw new Error("No ID token received");
    }
    
    const userInfo = jwtDecode(tokens.id_token);
    console.log("User info:", { 
      sub: userInfo.sub, 
      email: userInfo.email, 
      name: userInfo.name 
    });
    
    let profile;
    let isNewUser = false;
    
    const { data: existingProfile, error: fetchError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("google_id", userInfo.sub)
      .single();
    
    if (existingProfile) {
      console.log("Existing zkLogin user found - updating login time");
      
      const { data: updatedProfile, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          name: userInfo.name,
          picture: userInfo.picture
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("Profile update error:", updateError);
        throw new Error("Profile update failed");
      }
      
      profile = updatedProfile;
      console.log(`Retrieved existing Sui address: ${profile.sui_address}`);
      
    } else {
      console.log("New zkLogin user - creating profile");
      
      const userSalt = generateRandomness();
      const suiAddress = jwtToAddress(tokens.id_token, userSalt);
      
      console.log("Generated new Sui address:", suiAddress);
      
      const profileData = {
        email: userInfo.email,
        google_id: userInfo.sub,
        name: userInfo.name,
        picture: userInfo.picture,
        user_salt: userSalt,
        sui_address: suiAddress,
        auth_method: "zklogin",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: insertedProfile, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("Profile insert error:", insertError);
        throw new Error("Profile creation failed");
      }
      
      profile = insertedProfile;
      isNewUser = true;
    }
    
    const needsUsername = needsUsernameSetup(profile);
    
    sessions[state] = {
      id: userInfo.sub,
      email: userInfo.email,
      name: profile.name,
      picture: userInfo.picture,
      suiWallet: profile.sui_address,
      authMethod: "zklogin",
      profileId: profile.id,
      sub: userInfo.sub,
      aud: userInfo.aud,
      needsUsernameSetup: needsUsername
    };
    
    try {
      console.log(`Checking Sui balance for zkLogin user...`);
      
      const balance = await suiClient.getBalance({
        owner: profile.sui_address,
        coinType: '0x2::sui::SUI'
      });
      
      const formattedBalance = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4);
      console.log(`Sui Balance: ${formattedBalance} SUI (${balance.totalBalance} MIST)`);
      
    } catch (balanceError) {
      console.log(`Could not fetch balance: ${balanceError.message} (This is normal for new addresses)`);
    }
    
    console.log(`zkLogin successful for ${userInfo.email} - ${isNewUser ? 'New user created' : 'Existing user logged in'}`);
    
    const welcomeMessage = isNewUser ? 
      `Welcome to the game, ${userInfo.name}!` : 
      `Welcome back, ${userInfo.name}!`;
    
    res.send(`
      <html>
        <head>
          <title>Sign In Successful</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
            .container { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; max-width: 500px; margin: 0 auto; }
            .success { color: #4CAF50; font-size: 28px; margin-bottom: 20px; }
            .info { color: #f0f0f0; margin: 15px 0; font-size: 16px; }
            .wallet { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; word-break: break-all; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="success">Sign In Successful!</div>
            <div class="info">${welcomeMessage}</div>
            <div class="info">Your Sui Wallet:</div>
            <div class="wallet">${profile.sui_address}</div>
            <div class="info" style="margin-top: 20px;">You can now close this window and return to the game.</div>
          </div>
        </body>
      </html>
    `);
    
  } catch (err) {
    console.error("OAuth callback error:", err);
    res.status(500).send(`
      <html>
        <head>
          <title>Authentication Failed</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f44336; color: white; }
          </style>
        </head>
        <body>
          <h1>Authentication Failed</h1>
          <p>Error: ${err.message}</p>
          <p>Please close this window and try again.</p>
        </body>
      </html>
    `);
  }
});

// Unity polling endpoint
app.get("/getProfile", (req, res) => {
  const { state } = req.query;
  if (sessions[state]) {
    res.json(sessions[state]);
    delete sessions[state];
  } else {
    res.status(404).send("Not ready");
  }
});

// Health check
app.get("/ping", async (req, res) => {
  try {
    const chainId = await suiClient.getChainIdentifier();
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      network: NETWORK_CONFIG.current,
      chainId
    });
  } catch (err) {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      networkError: err.message
    });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
  console.log(`RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
});
























// // server.js - Enhanced with network configuration and Sui SDK
// import express from "express";
// import bodyParser from "body-parser";
// import fetch from "node-fetch";
// import { jwtDecode } from "jwt-decode";
// import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
// import { isValidSuiAddress } from "@mysten/sui/utils";

// // Updated Sui SDK imports - Fixed for current version
// import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
// import { Transaction } from '@mysten/sui/transactions'; // Changed from TransactionBlock
// import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

// import supabase from "./supabaseClient.js";

// const app = express();

// // Network Configuration
// const NETWORK_CONFIG = {
//   // Choose your network here:
//   current: process.env.SUI_NETWORK || 'test', // 'devnet', 'testnet', or 'mainnet'
  
//   // Network URLs (automatically handled by getFullnodeUrl)
//   devnet: 'https://fullnode.devnet.sui.io',
//   testnet: 'https://fullnode.testnet.sui.io', 
//   mainnet: 'https://fullnode.mainnet.sui.io'
// };

// // Initialize Sui Client
// const suiClient = new SuiClient({ 
//   url: getFullnodeUrl(NETWORK_CONFIG.current) 
// });

// console.log(`🌐 Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);
// console.log(`🔗 RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);

// // CORS middleware
// app.use((req, res, next) => {
//   res.header('Access-Control-Allow-Origin', '*');
//   res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
//   res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
//   if (req.method === 'OPTIONS') {
//     res.sendStatus(200);
//   } else {
//     next();
//   }
// });

// app.use(bodyParser.json());

// // Add request logging middleware
// app.use((req, res, next) => {
//   console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
//   if (req.body && Object.keys(req.body).length > 0) {
//     console.log('Request Body:', JSON.stringify(req.body, null, 2));
//   }
//   next();
// });

// const PORT = process.env.PORT || 3000;
// const sessions = {}; // { state: profile }

// // Helper function to get network info
// async function getNetworkInfo() {
//   try {
//     const chainId = await suiClient.getChainIdentifier();
//     const latestCheckpoint = await suiClient.getLatestCheckpointSequenceNumber();
    
//     return {
//       network: NETWORK_CONFIG.current,
//       chainId,
//       latestCheckpoint: latestCheckpoint.toString(),
//       rpcUrl: getFullnodeUrl(NETWORK_CONFIG.current)
//     };
//   } catch (error) {
//     console.error('Failed to get network info:', error);
//     return {
//       network: NETWORK_CONFIG.current,
//       error: error.message,
//       rpcUrl: getFullnodeUrl(NETWORK_CONFIG.current)
//     };
//   }
// }

// // Helper function to check if user needs username setup
// function needsUsernameSetup(profile) {
//   if (!profile || !profile.name) return true;
//   const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
//   return isAutoGenerated;
// }

// // Network status endpoint
// app.get("/network/status", async (req, res) => {
//   try {
//     const networkInfo = await getNetworkInfo();
    
//     res.json({
//       ...networkInfo,
//       timestamp: new Date().toISOString(),
//       supportedNetworks: ['devnet', 'testnet', 'mainnet']
//     });
//   } catch (err) {
//     console.error("Network status error:", err);
//     res.status(500).json({ 
//       error: "Failed to get network status",
//       message: err.message 
//     });
//   }
// });

// // Enhanced wallet validation with blockchain verification
// app.post("/validate-wallet", async (req, res) => {
//   console.log("🔍 Wallet validation request received");
  
//   try {
//     const { address } = req.body;
    
//     if (!address) {
//       return res.status(400).json({
//         valid: false,
//         address: null,
//         message: "No wallet address provided"
//       });
//     }
    
//     const cleanAddress = address.trim();
//     console.log(`🔍 Validating address: ${cleanAddress}`);
    
//     // Format validation
//     const isValidFormat = isValidSuiAddress(cleanAddress);
    
//     let blockchainInfo = {
//       exists: false,
//       balance: '0',
//       hasActivity: false,
//       error: null
//     };
    
//     // If format is valid, check blockchain
//     if (isValidFormat) {
//       try {
//         console.log('🔗 Checking blockchain status...');
        
//         // Check balance
//         const balance = await suiClient.getBalance({
//           owner: cleanAddress,
//           coinType: '0x2::sui::SUI'
//         });
        
//         // Check for any owned objects
//         const objects = await suiClient.getOwnedObjects({
//           owner: cleanAddress,
//           limit: 1
//         });
        
//         blockchainInfo = {
//           exists: true,
//           balance: balance.totalBalance,
//           balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
//           hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
//           network: NETWORK_CONFIG.current
//         };
        
//         console.log(`✅ Blockchain info:`, blockchainInfo);
        
//       } catch (blockchainError) {
//         console.log(`⚠️ Blockchain check failed: ${blockchainError.message}`);
//         blockchainInfo.error = blockchainError.message;
//         // Note: This is normal for new addresses that haven't been used yet
//       }
//     }
    
//     const responseData = {
//       valid: isValidFormat,
//       address: cleanAddress,
//       message: isValidFormat 
//         ? `Valid Sui address${blockchainInfo.exists ? ` (Balance: ${blockchainInfo.balanceFormatted})` : ' (Not yet active on blockchain)'}` 
//         : "Invalid Sui address format",
//       blockchain: blockchainInfo,
//       network: NETWORK_CONFIG.current
//     };
    
//     console.log("📤 Sending response:", responseData);
//     res.json(responseData);
    
//   } catch (err) {
//     console.error("❌ Validation error:", err);
//     res.status(500).json({
//       valid: false,
//       address: req.body?.address || null,
//       message: "Server error during validation: " + err.message
//     });
//   }
// });

// // Get detailed wallet information
// app.get("/wallet/:address/info", async (req, res) => {
//   const { address } = req.params;
  
//   try {
//     if (!isValidSuiAddress(address)) {
//       return res.status(400).json({ error: "Invalid wallet address" });
//     }
    
//     console.log(`🔍 Fetching wallet info for: ${address}`);
    
//     // Get balance for SUI
//     const suiBalance = await suiClient.getBalance({
//       owner: address,
//       coinType: '0x2::sui::SUI'
//     });
    
//     // Get all coin balances
//     const allBalances = await suiClient.getAllBalances({
//       owner: address
//     });
    
//     // Get owned objects (limited to 20 for performance)
//     const objects = await suiClient.getOwnedObjects({
//       owner: address,
//       limit: 20,
//       options: {
//         showType: true,
//         showContent: true
//       }
//     });
    
//     // Get recent transactions (limited to 10)
//     const transactions = await suiClient.queryTransactionBlocks({
//       filter: { FromAddress: address },
//       limit: 10,
//       order: 'descending'
//     });
    
//     // Analyze object types
//     const objectTypes = {};
//     objects.data.forEach(obj => {
//       if (obj.data?.type) {
//         const type = obj.data.type.split('::').pop() || obj.data.type;
//         objectTypes[type] = (objectTypes[type] || 0) + 1;
//       }
//     });
    
//     const walletInfo = {
//       address,
//       network: NETWORK_CONFIG.current,
//       balance: {
//         sui: {
//           amount: suiBalance.totalBalance,
//           formatted: (parseInt(suiBalance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI'
//         },
//         allCoins: allBalances
//       },
//       objects: {
//         total: objects.data.length,
//         types: objectTypes,
//         hasNFTs: Object.keys(objectTypes).some(type => !type.includes('Coin'))
//       },
//       activity: {
//         transactionCount: transactions.data.length,
//         recentTransactions: transactions.data.slice(0, 3).map(tx => ({
//           digest: tx.digest,
//           timestamp: tx.timestampMs ? new Date(parseInt(tx.timestampMs)).toISOString() : null
//         }))
//       },
//       status: {
//         isActive: parseInt(suiBalance.totalBalance) > 0 || objects.data.length > 0,
//         isEmpty: parseInt(suiBalance.totalBalance) === 0 && objects.data.length === 0
//       }
//     };
    
//     console.log(`✅ Wallet info retrieved for ${address}`);
//     res.json(walletInfo);
    
//   } catch (err) {
//     console.error("Wallet info error:", err);
//     res.status(500).json({ 
//       error: "Failed to fetch wallet info",
//       message: err.message,
//       address 
//     });
//   }
// });

// // Enhanced manual wallet connection with blockchain verification
// app.post("/auth/wallet", async (req, res) => {
//   const { walletAddress, state } = req.body;
  
//   try {
//     // Validate format
//     if (!walletAddress || !isValidSuiAddress(walletAddress)) {
//       return res.status(400).json({ 
//         success: false,
//         error: "Invalid Sui wallet address format" 
//       });
//     }
    
//     console.log("✅ Manual wallet connection:", { walletAddress });
    
//     // Optional blockchain verification
//     let blockchainStatus = null;
//     try {
//       const balance = await suiClient.getBalance({
//         owner: walletAddress,
//         coinType: '0x2::sui::SUI'
//       });
      
//       blockchainStatus = {
//         verified: true,
//         balance: balance.totalBalance,
//         network: NETWORK_CONFIG.current
//       };
      
//       console.log(`✅ Wallet verified on ${NETWORK_CONFIG.current}: ${balance.totalBalance} MIST`);
      
//     } catch (blockchainError) {
//       console.log(`⚠️ Wallet not active on ${NETWORK_CONFIG.current}: ${blockchainError.message}`);
//       blockchainStatus = {
//         verified: false,
//         error: blockchainError.message,
//         network: NETWORK_CONFIG.current
//       };
//     }
    
//     // Continue with existing database logic
//     let { data: existingProfile, error } = await supabase
//       .from("user_profiles")
//       .select("*")
//       .eq("sui_address", walletAddress)
//       .single();
    
//     let finalProfile;
//     let isNewUser = false;
    
//     if (existingProfile) {
//       // Update existing profile
//       const { data: updated, error: updateError } = await supabase
//         .from("user_profiles")
//         .update({ 
//           updated_at: new Date().toISOString()
//         })
//         .eq("id", existingProfile.id)
//         .select()
//         .single();
        
//       if (updateError) {
//         console.error("Profile update error:", updateError);
//         return res.status(500).json({ 
//           success: false,
//           error: "Profile update failed" 
//         });
//       }
      
//       finalProfile = updated;
//       console.log("✅ Existing wallet user logged in");
//     } else {
//       // Create new profile
//       const tempName = `Player_${walletAddress.substring(0, 8)}`;
      
//       const profileData = {
//         email: null,
//         google_id: null,
//         name: tempName,
//         picture: null,
//         user_salt: null,
//         sui_address: walletAddress,
//         auth_method: "manual_wallet",
//         created_at: new Date().toISOString(),
//         updated_at: new Date().toISOString()
//       };
      
//       const { data: inserted, error: insertError } = await supabase
//         .from("user_profiles")
//         .insert([profileData])
//         .select()
//         .single();
        
//       if (insertError) {
//         console.error("Profile insert error:", insertError);
//         return res.status(500).json({ 
//           success: false,
//           error: "Profile creation failed" 
//         });
//       }
      
//       finalProfile = inserted;
//       isNewUser = true;
//       console.log("✅ New wallet user created");
//     }
    
//     const needsUsername = needsUsernameSetup(finalProfile);
    
//     // Store session for Unity polling
//     if (state) {
//       sessions[state] = {
//         id: walletAddress.substring(0, 16),
//         email: finalProfile.email,
//         name: finalProfile.name,
//         picture: finalProfile.picture,
//         suiWallet: walletAddress,
//         authMethod: "manual_wallet",
//         profileId: finalProfile.id,
//         needsUsernameSetup: needsUsername
//       };
//     }
    
//     res.json({
//       success: true,
//       message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
//       needsUsernameSetup: needsUsername,
//       blockchain: blockchainStatus,
//       profile: {
//         id: finalProfile.id,
//         name: finalProfile.name,
//         suiWallet: walletAddress,
//         authMethod: "manual_wallet",
//         profileId: finalProfile.id,
//         needsUsernameSetup: needsUsername
//       }
//     });
    
//   } catch (err) {
//     console.error("Manual wallet connection error:", err);
//     res.status(500).json({ 
//       success: false,
//       error: "Wallet connection failed: " + err.message 
//     });
//   }
// });

// // Username setup endpoint
// app.post("/setup-username", async (req, res) => {
//   const { walletAddress, username } = req.body;
  
//   try {
//     if (!walletAddress || !username) {
//       return res.status(400).json({
//         success: false,
//         error: "Wallet address and username are required"
//       });
//     }
    
//     const trimmedUsername = username.trim();
    
//     // Validate username
//     if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
//       return res.status(400).json({
//         success: false,
//         error: "Username must be between 3 and 20 characters"
//       });
//     }
    
//     if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
//       return res.status(400).json({
//         success: false,
//         error: "Username can only contain letters, numbers, underscore, and hyphen"
//       });
//     }
    
//     // Check if username already exists
//     const { data: existingUser, error: checkError } = await supabase
//       .from("user_profiles")
//       .select("id")
//       .eq("name", trimmedUsername)
//       .neq("sui_address", walletAddress)
//       .single();
    
//     if (existingUser) {
//       return res.status(400).json({
//         success: false,
//         error: "Username already taken"
//       });
//     }
    
//     // Update user profile
//     const { data: updatedProfile, error: updateError } = await supabase
//       .from("user_profiles")
//       .update({ 
//         name: trimmedUsername,
//         updated_at: new Date().toISOString()
//       })
//       .eq("sui_address", walletAddress)
//       .select()
//       .single();
      
//     if (updateError) {
//       console.error("Username update error:", updateError);
//       return res.status(500).json({
//         success: false,
//         error: "Failed to update username"
//       });
//     }
    
//     res.json({
//       success: true,
//       message: "Username updated successfully",
//       profile: {
//         id: updatedProfile.id,
//         name: updatedProfile.name,
//         suiWallet: updatedProfile.sui_address,
//         authMethod: updatedProfile.auth_method,
//         profileId: updatedProfile.id,
//         needsUsernameSetup: false
//       }
//     });
    
//   } catch (err) {
//     console.error("Username setup error:", err);
//     res.status(500).json({
//       success: false,
//       error: "Username setup failed: " + err.message
//     });
//   }
// });

// // Replace your existing Google OAuth callback handler with this fixed version

// // Google OAuth callback 
// app.get("/auth/google/callback", async (req, res) => {
//   const { code, state } = req.query;
  
//   if (!code) {
//     console.error("❌ No authorization code received");
//     return res.status(400).send("Authorization failed - no code");
//   }
  
//   try {
//     console.log("🔄 Processing Google OAuth callback...");
    
//     // Exchange code for tokens
//     const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
//       method: "POST",
//       headers: { "Content-Type": "application/x-www-form-urlencoded" },
//       body: new URLSearchParams({
//         code,
//         client_id: process.env.GOOGLE_CLIENT_ID,
//         client_secret: process.env.GOOGLE_CLIENT_SECRET,
//         redirect_uri: process.env.REDIRECT_URI,
//         grant_type: "authorization_code"
//       })
//     });
    
//     const tokens = await tokenResponse.json();
    
//     if (!tokens.id_token) {
//       throw new Error("No ID token received");
//     }
    
//     // Decode JWT to get user info
//     const userInfo = jwtDecode(tokens.id_token);
//     console.log("👤 User info:", { 
//       sub: userInfo.sub, 
//       email: userInfo.email, 
//       name: userInfo.name 
//     });
    
//     let profile;
//     let isNewUser = false;
    
//     // Check if user already exists
//     const { data: existingProfile, error: fetchError } = await supabase
//       .from("user_profiles")
//       .select("*")
//       .eq("google_id", userInfo.sub)
//       .single();
    
//     if (existingProfile) {
//       console.log("✅ Existing zkLogin user found - updating login time");
      
//       // Update existing user's last login
//       const { data: updatedProfile, error: updateError } = await supabase
//         .from("user_profiles")
//         .update({ 
//           updated_at: new Date().toISOString(),
//           // Update name and picture in case they changed on Google
//           name: userInfo.name,
//           picture: userInfo.picture
//         })
//         .eq("id", existingProfile.id)
//         .select()
//         .single();
        
//       if (updateError) {
//         console.error("❌ Profile update error:", updateError);
//         throw new Error("Profile update failed");
//       }
      
//       profile = updatedProfile;
//       console.log(`🔐 Retrieved existing Sui address: ${profile.sui_address}`);
      
//     } else {
//       console.log("🆕 New zkLogin user - creating profile");
      
//       // Generate Sui address using zkLogin for new users
//       const userSalt = generateRandomness();
//       const suiAddress = jwtToAddress(tokens.id_token, userSalt);
      
//       console.log("🔐 Generated new Sui address:", suiAddress);
      
//       // Create new user profile
//       const profileData = {
//         email: userInfo.email,
//         google_id: userInfo.sub,
//         name: userInfo.name,
//         picture: userInfo.picture,
//         user_salt: userSalt,
//         sui_address: suiAddress,
//         auth_method: "zklogin",
//         created_at: new Date().toISOString(),
//         updated_at: new Date().toISOString()
//       };
      
//       const { data: insertedProfile, error: insertError } = await supabase
//         .from("user_profiles")
//         .insert([profileData])
//         .select()
//         .single();
        
//       if (insertError) {
//         console.error("❌ Profile insert error:", insertError);
//         throw new Error("Profile creation failed");
//       }
      
//       profile = insertedProfile;
//       isNewUser = true;
//     }
    
//     const needsUsername = needsUsernameSetup(profile);
    
//     // Store session for Unity to poll
//     sessions[state] = {
//       id: userInfo.sub,
//       email: userInfo.email,
//       name: profile.name,
//       picture: userInfo.picture,
//       suiWallet: profile.sui_address,
//       authMethod: "zklogin",
//       profileId: profile.id,
//       sub: userInfo.sub,
//       aud: userInfo.aud,
//       needsUsernameSetup: needsUsername
//     };
    
//     // Fetch and display wallet balance in logs
//     try {
//       console.log(`💰 Checking Sui balance for zkLogin user...`);
      
//       const balance = await suiClient.getBalance({
//         owner: profile.sui_address,
//         coinType: '0x2::sui::SUI'
//       });
      
//       const formattedBalance = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4);
//       console.log(`💰 Sui Balance: ${formattedBalance} SUI (${balance.totalBalance} MIST)`);
      
//       // Optional: Check for any owned objects
//       const objects = await suiClient.getOwnedObjects({
//         owner: profile.sui_address,
//         limit: 5
//       });
      
//       console.log(`📦 Owned Objects: ${objects.data.length} items`);
      
//     } catch (balanceError) {
//       console.log(`⚠️ Could not fetch balance: ${balanceError.message} (This is normal for new addresses)`);
//     }
    
//     console.log(`✅ zkLogin successful for ${userInfo.email} - ${isNewUser ? 'New user created' : 'Existing user logged in'}`);
    
//     // Return success page with appropriate message
//     const welcomeMessage = isNewUser ? 
//       `Welcome to the game, ${userInfo.name}!` : 
//       `Welcome back, ${userInfo.name}!`;
    
//     res.send(`
//       <html>
//         <head>
//           <title>Sign In Successful</title>
//           <style>
//             body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
//             .container { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; max-width: 500px; margin: 0 auto; }
//             .success { color: #4CAF50; font-size: 28px; margin-bottom: 20px; }
//             .info { color: #f0f0f0; margin: 15px 0; font-size: 16px; }
//             .wallet { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; word-break: break-all; }
//           </style>
//         </head>
//         <body>
//           <div class="container">
//             <div class="success">✅ Sign In Successful!</div>
//             <div class="info">${welcomeMessage}</div>
//             <div class="info">Your Sui Wallet:</div>
//             <div class="wallet">${profile.sui_address}</div>
//             <div class="info" style="margin-top: 20px;">You can now close this window and return to the game.</div>
//           </div>
//         </body>
//       </html>
//     `);
    
//   } catch (err) {
//     console.error("❌ OAuth callback error:", err);
//     res.status(500).send(`
//       <html>
//         <head>
//           <title>Authentication Failed</title>
//           <style>
//             body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f44336; color: white; }
//           </style>
//         </head>
//         <body>
//           <h1>❌ Authentication Failed</h1>
//           <p>Error: ${err.message}</p>
//           <p>Please close this window and try again.</p>
//         </body>
//       </html>
//     `);
//   }
// });

// // Unity polling endpoint
// app.get("/getProfile", (req, res) => {
//   const { state } = req.query;
//   if (sessions[state]) {
//     res.json(sessions[state]);
//     delete sessions[state];
//   } else {
//     res.status(404).send("Not ready");
//   }
// });

// // Enhanced health check with network info
// app.get("/ping", async (req, res) => {
//   try {
//     const networkInfo = await getNetworkInfo();
//     res.json({
//       status: "ok",
//       timestamp: new Date().toISOString(),
//       message: "Server is running",
//       network: networkInfo
//     });
//   } catch (err) {
//     res.json({
//       status: "ok",
//       timestamp: new Date().toISOString(),
//       message: "Server is running",
//       networkError: err.message
//     });
//   }
// });

// // Test endpoint with your specific address
// app.get("/test-validation", async (req, res) => {
//   const testAddress = "0x59435d7c7acd3a3d17c8701d9384b25fdafd7669307dea06a8a70c8bd3fb52d0";
  
//   try {
//     const isValid = isValidSuiAddress(testAddress);
//     let blockchainInfo = null;
    
//     if (isValid) {
//       try {
//         const balance = await suiClient.getBalance({
//           owner: testAddress,
//           coinType: '0x2::sui::SUI'
//         });
        
//         blockchainInfo = {
//           balance: balance.totalBalance,
//           formatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
//           network: NETWORK_CONFIG.current
//         };
//       } catch (err) {
//         blockchainInfo = { error: err.message };
//       }
//     }
    
//     res.json({
//       testAddress,
//       formatValid: isValid,
//       blockchain: blockchainInfo,
//       network: NETWORK_CONFIG.current,
//       message: `Test validation: ${isValid ? 'PASSED' : 'FAILED'}`,
//       serverTime: new Date().toISOString()
//     });
//   } catch (err) {
//     res.status(500).json({
//       error: "Test validation failed",
//       message: err.message
//     });
//   }
// });

// app.listen(PORT, () => {
//   console.log(`🚀 Server running on port ${PORT}`);
//   console.log(`🌐 Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
//   console.log(`🔗 RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
// });
