// server.js - Enhanced with browser wallet redirect support
import express from "express";
import bodyParser from "body-parser";
import fetch from "node-fetch";
import { jwtDecode } from "jwt-decode";
import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
import { isValidSuiAddress } from "@mysten/sui/utils";
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

import supabase from "./supabaseClient.js";

const app = express();

// Network Configuration
const NETWORK_CONFIG = {
  current: process.env.SUI_NETWORK || 'testnet',
  devnet: 'https://fullnode.devnet.sui.io',
  testnet: 'https://fullnode.testnet.sui.io', 
  mainnet: 'https://fullnode.mainnet.sui.io'
};

// Initialize Sui Client
const suiClient = new SuiClient({ 
  url: getFullnodeUrl(NETWORK_CONFIG.current) 
});

console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);

// CORS middleware
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

app.use(bodyParser.json());

// Add request logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('Request Body:', JSON.stringify(req.body, null, 2));
  }
  next();
});

const PORT = process.env.PORT || 3000;
const sessions = {}; // { state: profile }

// Helper function to check if user needs username setup
function needsUsernameSetup(profile) {
  if (!profile || !profile.name) return true;
  const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
  return isAutoGenerated;
}


app.get("/wallet-connect", (req, res) => {
  const { state } = req.query;
  
  if (!state) {
    return res.status(400).send("Missing state parameter");
  }

  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Connect Your Sui Wallet</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                margin: 0;
                padding: 20px;
                min-height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .container {
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                max-width: 500px;
                width: 100%;
            }
            .title { color: #333; font-size: 24px; margin-bottom: 20px; text-align: center; }
            .status { padding: 15px; border-radius: 8px; margin: 15px 0; text-align: center; font-weight: bold; }
            .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
            .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
            .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
            .section { margin: 25px 0; padding: 20px; border: 2px solid #e9ecef; border-radius: 10px; }
            .wallet-item { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .wallet-detected { border-color: #28a745; background: #f8fff9; }
            .wallet-connected { border-color: #007bff; background: #e7f3ff; }
            .button {
                padding: 12px 20px;
                border: none;
                border-radius: 6px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s;
                min-width: 100px;
            }
            .button-primary { background: #007bff; color: white; }
            .button-primary:hover:not(:disabled) { background: #0056b3; }
            .button-success { background: #28a745; color: white; }
            .button-success:hover:not(:disabled) { background: #1e7e34; }
            .button:disabled { background: #6c757d; cursor: not-allowed; opacity: 0.6; }
            .input { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; margin: 10px 0; box-sizing: border-box; }
            .input:focus { border-color: #007bff; outline: none; }
            .loading { display: none; text-align: center; margin: 20px 0; }
            .spinner { border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto; }
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            .wallet-icon { width: 24px; height: 24px; margin-right: 10px; vertical-align: middle; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="title">Connect Your Sui Wallet</div>
            
            <div id="status" class="status info">Detecting wallet extensions...</div>
            
            <!-- Browser Wallet Section -->
            <div class="section">
                <h3>Browser Wallet Extensions</h3>
                <div id="wallet-list">
                    <div class="wallet-item" id="sui-wallet-item">
                        <div>
                            <strong>Sui Wallet</strong>
                            <div id="sui-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="sui-connect" onclick="connectBrowserWallet('sui')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="suiet-item">
                        <div>
                            <strong>Suiet</strong>
                            <div id="suiet-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="suiet-connect" onclick="connectBrowserWallet('suiet')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="ethos-item">
                        <div>
                            <strong>Ethos</strong>
                            <div id="ethos-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="ethos-connect" onclick="connectBrowserWallet('ethos')" disabled>Connect</button>
                    </div>
                    
                    <div class="wallet-item" id="slush-item">
                        <div>
                            <strong>Slush Wallet</strong>
                            <div id="slush-status">Checking...</div>
                        </div>
                        <button class="button button-primary" id="slush-connect" onclick="connectBrowserWallet('slush')" disabled>Connect</button>
                    </div>
                </div>
            </div>
            
            <!-- Manual Connection Section -->
            <div class="section">
                <h3>Manual Connection</h3>
                <p>Enter your Sui wallet address directly:</p>
                <input type="text" 
                       class="input" 
                       id="manual-address" 
                       placeholder="0x1234567890abcdef..."
                       oninput="validateManualInput()">
                <button class="button button-success" 
                        id="manual-connect" 
                        onclick="connectManualWallet()" 
                        disabled>Connect Manual Wallet</button>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing connection...</p>
            </div>
        </div>

        <script>
            const STATE = '${state}';
            let walletCheckComplete = false;
            let detectionAttempts = 0;
            const MAX_DETECTION_ATTEMPTS = 5;
            
            // Enhanced wallet detection with better Slush support
            const WALLET_CONFIGS = {
                'sui': {
                    name: 'Sui Wallet',
                    check: function() { 
                        return window.suiWallet || window.sui; 
                    },
                    connect: async function(wallet) {
                        if (wallet.connect) {
                            return await wallet.connect();
                        } else if (wallet.requestPermissions) {
                            return await wallet.requestPermissions();
                        }
                        throw new Error('Unsupported connection method');
                    }
                },
                'suiet': {
                    name: 'Suiet',
                    check: function() { 
                        return window.suiet; 
                    },
                    connect: async function(wallet) {
                        if (wallet.connect) return await wallet.connect();
                        throw new Error('Unsupported connection method');
                    }
                },
                'ethos': {
                    name: 'Ethos',
                    check: function() { 
                        return window.ethos; 
                    },
                    connect: async function(wallet) {
                        if (wallet.connect) return await wallet.connect();
                        throw new Error('Unsupported connection method');
                    }
                },
                'slush': {
                    name: 'Slush Wallet',
                    check: function() { 
                        // Multiple possible global objects for Slush
                        return window.slush || window.slushWallet || 
                               (window.sui && window.sui._isSlush) || 
                               document.querySelector('meta[name="slush-wallet"]');
                    },
                    connect: async function(wallet) {
                        // Slush-specific connection logic
                        if (wallet.connect) {
                            return await wallet.connect();
                        } else if (wallet.requestPermissions) {
                            return await wallet.requestPermissions();
                        } else if (wallet.getAccounts) {
                            const accounts = await wallet.getAccounts();
                            return { accounts };
                        }
                        throw new Error('Unsupported connection method for Slush');
                    }
                }
            };
            
            // Enhanced wallet detection with retry logic
            function checkWallets() {
                console.log('ðŸ” Checking wallets (attempt ' + (detectionAttempts + 1) + ')...');
                
                let detectedCount = 0;
                
                for (const [walletId, config] of Object.entries(WALLET_CONFIGS)) {
                    const statusEl = document.getElementById(walletId + '-status');
                    const connectEl = document.getElementById(walletId + '-connect');
                    const itemEl = document.getElementById(walletId + '-item');
                    
                    try {
                        const detected = config.check();
                        console.log('Wallet ' + walletId + ':', detected ? 'âœ… DETECTED' : 'âŒ not found');
                        
                        if (detected) {
                            statusEl.textContent = 'Detected';
                            statusEl.style.color = '#28a745';
                            connectEl.disabled = false;
                            itemEl.classList.add('wallet-detected');
                            detectedCount++;
                            
                            // Store the actual wallet object for later use
                            let walletObj;
                            if (walletId === 'slush') {
                                walletObj = window.slush || window.slushWallet || window.sui;
                            } else {
                                walletObj = detected;
                            }
                            window[walletId + 'Wallet'] = walletObj;
                            
                        } else {
                            statusEl.textContent = 'Not installed';
                            statusEl.style.color = '#6c757d';
                            connectEl.disabled = true;
                            itemEl.classList.remove('wallet-detected');
                        }
                    } catch (error) {
                        console.error('Error checking ' + walletId + ':', error);
                        statusEl.textContent = 'Check failed';
                        statusEl.style.color = '#dc3545';
                        connectEl.disabled = true;
                    }
                }
                
                detectionAttempts++;
                
                if (detectedCount > 0 || detectionAttempts >= MAX_DETECTION_ATTEMPTS) {
                    walletCheckComplete = true;
                    updateStatus(
                        detectedCount > 0 ? 
                        detectedCount + ' wallet(s) detected. Choose one to connect.' : 
                        'No browser wallets detected. Use manual connection below.', 
                        detectedCount > 0 ? 'success' : 'info'
                    );
                    console.log('âœ… Wallet detection complete. Found:', detectedCount);
                } else {
                    // Retry after delay
                    setTimeout(checkWallets, 1000);
                }
            }
            
            // Enhanced browser wallet connection
            async function connectBrowserWallet(walletType) {
                console.log('ðŸ”— Connecting to:', walletType);
                showLoading(true);
                
                try {
                    const wallet = window[walletType + 'Wallet'];
                    if (!wallet) {
                        throw new Error(walletType + ' wallet not found');
                    }
                    
                    updateStatus('Requesting wallet permission...', 'info');
                    
                    const config = WALLET_CONFIGS[walletType];
                    const result = await config.connect(wallet);
                    
                    let accounts;
                    if (result.accounts) {
                        accounts = result.accounts;
                    } else if (Array.isArray(result)) {
                        accounts = result;
                    } else if (result.address) {
                        accounts = [result];
                    } else {
                        throw new Error('Unexpected response format from wallet');
                    }
                    
                    if (!accounts || accounts.length === 0) {
                        throw new Error('No accounts found');
                    }
                    
                    const address = accounts[0].address || accounts[0];
                    console.log('âœ… Got wallet address:', address);
                    
                    // Visual feedback
                    document.getElementById(walletType + '-item').classList.add('wallet-connected');
                    document.getElementById(walletType + '-status').textContent = 'Connected';
                    
                    await submitWalletConnection({
                        walletAddress: address,
                        walletName: walletType,
                        signature: '',
                        message: '',
                        state: STATE
                    });
                    
                } catch (error) {
                    console.error('âŒ Wallet connection failed:', error);
                    updateStatus('Connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Validate manual input
            function validateManualInput() {
                const address = document.getElementById('manual-address').value.trim();
                const button = document.getElementById('manual-connect');
                
                // Basic Sui address validation
                if (address.length >= 60 && address.startsWith('0x')) {
                    button.disabled = false;
                } else {
                    button.disabled = true;
                }
            }
            
            // Connect manual wallet
            async function connectManualWallet() {
                const address = document.getElementById('manual-address').value.trim();
                console.log('ðŸ”— Manual wallet connection:', address);
                
                showLoading(true);
                updateStatus('Connecting manual wallet...', 'info');
                
                try {
                    await submitWalletConnection({
                        walletAddress: address,
                        walletName: 'manual',
                        signature: '',
                        message: '',
                        state: STATE
                    });
                } catch (error) {
                    console.error('âŒ Manual wallet connection failed:', error);
                    updateStatus('Manual connection failed: ' + error.message, 'error');
                    showLoading(false);
                }
            }
            
            // Submit connection to server
            async function submitWalletConnection(data) {
                console.log('ðŸ“¤ Submitting to server:', data);
                
                try {
                    const response = await fetch('/auth/browser-wallet', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    const responseText = await response.text();
                    console.log('Server response:', response.status, responseText);
                    
                    if (!response.ok) {
                        throw new Error('Server error: ' + response.status + ' - ' + responseText);
                    }
                    
                    const result = JSON.parse(responseText);
                    
                    if (result.success) {
                        updateStatus('âœ… SUCCESS! Wallet connected. You can close this window.', 'success');
                        setTimeout(function() { 
                            try { 
                                window.close(); 
                            } catch(e) { 
                                console.log('Cannot auto-close window'); 
                            }
                        }, 2000);
                    } else {
                        throw new Error(result.error || 'Unknown error');
                    }
                    
                } catch (error) {
                    console.error('âŒ Submit connection error:', error);
                    throw error;
                }
            }
            
            // Helper functions
            function updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = 'status ' + type;
                console.log('Status:', type, '-', message);
            }
            
            function showLoading(show) {
                const loading = document.getElementById('loading');
                if (show) {
                    loading.style.display = 'block';
                    // Disable all buttons
                    const buttons = document.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = true);
                } else {
                    loading.style.display = 'none';
                    // Re-run wallet check to re-enable appropriate buttons
                    if (walletCheckComplete) {
                        checkWallets();
                        validateManualInput();
                    }
                }
            }
            
            // Enhanced initialization
            function init() {
                console.log('ðŸš€ Initializing wallet connection page with state:', STATE);
                updateStatus('Detecting wallet extensions...', 'info');
                
                // Start detection with retry mechanism
                checkWallets();
                
                // Additional check for slow-loading extensions
                setTimeout(() => {
                    if (!walletCheckComplete) {
                        console.log('ðŸ”„ Running additional wallet check...');
                        checkWallets();
                    }
                }, 3000);
            }
            
            // Start when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
            
            // Listen for wallet injection events (some wallets inject later)
            window.addEventListener('slush#initialized', () => {
                console.log('ðŸŽ¯ Slush wallet initialized event received');
                if (!walletCheckComplete) checkWallets();
            });
            
        </script>
    </body>
    </html>
  `);
});

// Fixed browser wallet authentication endpoint - using the same pattern as manual wallet
app.post("/auth/browser-wallet", async (req, res) => {
  console.log("ðŸ”— Browser wallet connection request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { 
      walletAddress, 
      signature, 
      message, 
      walletName, 
      state 
    } = req.body;
    
    // Basic validation
    if (!walletAddress) {
      console.log("âŒ Missing wallet address");
      return res.status(400).json({
        success: false,
        error: "Missing wallet address"
      });
    }
    
    if (!state) {
      console.log("âŒ Missing state parameter");
      return res.status(400).json({
        success: false,
        error: "Missing state parameter"
      });
    }
    
    // Validate Sui address format
    if (!isValidSuiAddress(walletAddress)) {
      console.log("âŒ Invalid address format:", walletAddress);
      return res.status(400).json({
        success: false,
        error: "Invalid Sui address format"
      });
    }
    
    console.log(`âœ… Valid wallet address: ${walletAddress}`);
    console.log(`ðŸ”— Browser wallet connecting: ${walletName || 'Unknown'} - ${walletAddress}`);
    
    // Check blockchain status
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      network: NETWORK_CONFIG.current,
      error: null
    };
    
    try {
      console.log('ðŸ”— Checking blockchain status...');
      
      const balance = await suiClient.getBalance({
        owner: walletAddress,
        coinType: '0x2::sui::SUI'
      });
      
      const objects = await suiClient.getOwnedObjects({
        owner: walletAddress,
        limit: 1
      });
      
      blockchainInfo = {
        exists: true,
        balance: balance.totalBalance,
        balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
        hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
        network: NETWORK_CONFIG.current
      };
      
      console.log(`âœ… Blockchain verified:`, blockchainInfo);
      
    } catch (blockchainError) {
      console.log(`âš ï¸ Blockchain check failed: ${blockchainError.message}`);
      blockchainInfo.error = blockchainError.message;
    }
    
    // Check if user already exists - using same pattern as manual wallet
    let { data: existingProfile, error: queryError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("sui_address", walletAddress)
      .single();
    
    if (queryError && queryError.code !== 'PGRST116') { // PGRST116 is "not found"
      console.error("âŒ Database query error:", queryError);
      return res.status(500).json({ 
        success: false,
        error: "Database query failed" 
      });
    }
    
    let finalProfile;
    let isNewUser = false;
    
    if (existingProfile) {
      console.log("âœ… Found existing user profile:", existingProfile.id);
      
      // Update existing profile - using simple approach like manual wallet
      const { data: updated, error: updateError } = await supabase
        .from("user_profiles")
        .update({ 
          updated_at: new Date().toISOString(),
          auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet'
        })
        .eq("id", existingProfile.id)
        .select()
        .single();
        
      if (updateError) {
        console.error("âŒ Profile update error:", updateError);
        return res.status(500).json({ 
          success: false,
          error: "Profile update failed" 
        });
      }
      
      finalProfile = updated;
      console.log("âœ… Existing user profile updated");
    } else {
      console.log("ðŸ†• Creating new user profile");
      
      const tempName = `Player_${walletAddress.substring(0, 8)}`;
      
      // Use the same profile data structure as manual wallet (which works)
      const profileData = {
        email: null,
        google_id: null,
        name: tempName,
        picture: null,
        user_salt: null,
        sui_address: walletAddress,
        auth_method: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      const { data: inserted, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();
        
      if (insertError) {
        console.error("âŒ Profile insert error:", insertError);
        return res.status(500).json({ 
          success: false,
          error: "Profile creation failed: " + insertError.message 
        });
      }
      
      finalProfile = inserted;
      isNewUser = true;
      console.log("âœ… New user profile created:", finalProfile.id);
    }
    
    const needsUsername = needsUsernameSetup(finalProfile);
    console.log(`Username setup needed: ${needsUsername}`);
    
    // Create session for Unity polling - using same format as manual wallet
    const sessionData = {
      id: finalProfile.id,
      email: finalProfile.email,
      name: finalProfile.name,
      picture: finalProfile.picture,
      suiWallet: walletAddress,
      authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
      profileId: finalProfile.id,
      needsUsernameSetup: needsUsername
    };
    
    // Store session for Unity polling
    sessions[state] = sessionData;
    console.log("âœ… Session stored with state:", state);
    console.log("Session data:", JSON.stringify(sessionData, null, 2));
    
    // Use same response format as manual wallet (which works)
    const responseData = {
      success: true,
      message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
      needsUsernameSetup: needsUsername,
      blockchain: {
        verified: blockchainInfo.exists,
        balance: blockchainInfo.balance,
        balanceFormatted: blockchainInfo.balanceFormatted,
        network: blockchainInfo.network,
        error: blockchainInfo.error
      },
      profile: {
        id: finalProfile.id,
        name: finalProfile.name,
        suiWallet: walletAddress,
        authMethod: walletName === 'manual' ? 'manual_wallet' : 'browser_wallet',
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername
      }
    };
    
    console.log("âœ… Sending success response:", JSON.stringify(responseData, null, 2));
    res.json(responseData);
    
  } catch (err) {
    console.error("âŒ Browser wallet connection error:", err);
    res.status(500).json({ 
      success: false,
      error: "Wallet connection failed: " + err.message 
    });
  }
});


// Enhanced wallet validation with better debugging
app.post("/validate-wallet", async (req, res) => {
  console.log("ðŸ” Wallet validation request received");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  
  try {
    const { address } = req.body;
    
    if (!address) {
      console.log("âŒ No address provided");
      return res.status(400).json({
        valid: false,
        address: null,
        message: "No wallet address provided"
      });
    }
    
    const cleanAddress = address.trim();
    console.log(`ðŸ” Validating address: ${cleanAddress}`);
    
    const isValidFormat = isValidSuiAddress(cleanAddress);
    console.log(`Address format validation: ${isValidFormat}`);
    
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      error: null
    };
    
    if (isValidFormat) {
      try {
        console.log('ðŸ”— Checking blockchain status...');
        
        const balance = await suiClient.getBalance({
          owner: cleanAddress,
          coinType: '0x2::sui::SUI'
        });
        
        const objects = await suiClient.getOwnedObjects({
          owner: cleanAddress,
          limit: 1
        });
        
        blockchainInfo = {
          exists: true,
          balance: balance.totalBalance,
          balanceFormatted: (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI',
          hasActivity: parseInt(balance.totalBalance) > 0 || objects.data.length > 0,
          network: NETWORK_CONFIG.current
        };
        
        console.log(`âœ… Blockchain info:`, blockchainInfo);
        
      } catch (blockchainError) {
        console.log(`âš ï¸ Blockchain check failed: ${blockchainError.message}`);
        blockchainInfo.error = blockchainError.message;
        // Still valid format, just not active on blockchain yet
      }
    }
    
    const responseData = {
      valid: isValidFormat,
      address: cleanAddress,
      message: isValidFormat 
        ? (blockchainInfo.exists 
           ? `Valid Sui address (Balance: ${blockchainInfo.balanceFormatted})` 
           : 'Valid Sui address (Not yet active on blockchain)')
        : "Invalid Sui address format",
      blockchain: blockchainInfo,
      network: NETWORK_CONFIG.current
    };
    
    console.log("Sending validation response:", responseData);
    res.json(responseData);
    
  } catch (err) {
    console.error("Validation error:", err);
    res.status(500).json({
      valid: false,
      address: req.body?.address || null,
      message: "Server error during validation: " + err.message
    });
  }
});

// Username setup endpoint
app.post("/setup-username", async (req, res) => {
  const { walletAddress, username } = req.body;
  
  try {
    if (!walletAddress || !username) {
      return res.status(400).json({
        success: false,
        error: "Wallet address and username are required"
      });
    }
    
    const trimmedUsername = username.trim();
    
    if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
      return res.status(400).json({
        success: false,
        error: "Username must be between 3 and 20 characters"
      });
    }
    
    if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
      return res.status(400).json({
        success: false,
        error: "Username can only contain letters, numbers, underscore, and hyphen"
      });
    }
    
    const { data: existingUser, error: checkError } = await supabase
      .from("user_profiles")
      .select("id")
      .eq("name", trimmedUsername)
      .neq("sui_address", walletAddress)
      .single();
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: "Username already taken"
      });
    }
    
    const { data: updatedProfile, error: updateError } = await supabase
      .from("user_profiles")
      .update({ 
        name: trimmedUsername,
        updated_at: new Date().toISOString()
      })
      .eq("sui_address", walletAddress)
      .select()
      .single();
      
    if (updateError) {
      console.error("Username update error:", updateError);
      return res.status(500).json({
        success: false,
        error: "Failed to update username"
      });
    }
    
    res.json({
      success: true,
      message: "Username updated successfully",
      profile: {
        id: updatedProfile.id,
        name: updatedProfile.name,
        suiWallet: updatedProfile.sui_address,
        authMethod: updatedProfile.auth_method,
        profileId: updatedProfile.id,
        needsUsernameSetup: false
      }
    });
    
  } catch (err) {
    console.error("Username setup error:", err);
    res.status(500).json({
      success: false,
      error: "Username setup failed: " + err.message
    });
  }
});


// Fixed Google OAuth callback section
app.get("/auth/google/callback", async (req, res) => {
    const { code, state } = req.query;
    
    if (!code) {
        console.error("No authorization code received");
        return res.status(400).send("Authorization failed - no code");
    }

    try {
        console.log("Processing Google OAuth callback...");
        
        const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
                code,
                client_id: process.env.GOOGLE_CLIENT_ID,
                client_secret: process.env.GOOGLE_CLIENT_SECRET,
                redirect_uri: process.env.REDIRECT_URI,
                grant_type: "authorization_code"
            })
        });

        const tokens = await tokenResponse.json();
        if (!tokens.id_token) {
            throw new Error("No ID token received");
        }

        const userInfo = jwtDecode(tokens.id_token);
        console.log("User info:", {
            sub: userInfo.sub,
            email: userInfo.email,
            name: userInfo.name
        });

        let profile;
        let isNewUser = false;

        const { data: existingProfile, error: fetchError } = await supabase
            .from("user_profiles")
            .select("*")
            .eq("google_id", userInfo.sub)
            .single();

        if (existingProfile) {
            console.log("Existing zkLogin user found - checking if username needs preservation");
            
            // Check if user has a custom username (not auto-generated and not Google name)
            const hasCustomUsername = existingProfile.name && 
                                    !existingProfile.name.startsWith('Player_0x') &&
                                    existingProfile.name !== userInfo.name;
            
            console.log(`Existing name: "${existingProfile.name}"`);
            console.log(`Google name: "${userInfo.name}"`);
            console.log(`Has custom username: ${hasCustomUsername}`);
            
            // Prepare update data - preserve custom username if it exists
            const updateData = {
                updated_at: new Date().toISOString(),
                picture: userInfo.picture, // Always update picture
                email: userInfo.email      // Always update email in case it changed
            };
            
            // Only update name if user doesn't have a custom username
            if (!hasCustomUsername) {
                updateData.name = userInfo.name;
                console.log("No custom username detected - updating name from Google profile");
            } else {
                console.log("Custom username detected - preserving existing name");
            }

            const { data: updatedProfile, error: updateError } = await supabase
                .from("user_profiles")
                .update(updateData)
                .eq("id", existingProfile.id)
                .select()
                .single();

            if (updateError) {
                console.error("Profile update error:", updateError);
                throw new Error("Profile update failed");
            }

            profile = updatedProfile;
            console.log(`Final profile name: "${profile.name}"`);
            console.log(`Retrieved existing Sui address: ${profile.sui_address}`);
            
        } else {
            console.log("New zkLogin user - creating profile");
            
            const userSalt = generateRandomness();
            const suiAddress = jwtToAddress(tokens.id_token, userSalt);
            console.log("Generated new Sui address:", suiAddress);

            const profileData = {
                email: userInfo.email,
                google_id: userInfo.sub,
                name: userInfo.name, // For new users, use Google name initially
                picture: userInfo.picture,
                user_salt: userSalt,
                sui_address: suiAddress,
                auth_method: "zklogin",
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };

            const { data: insertedProfile, error: insertError } = await supabase
                .from("user_profiles")
                .insert([profileData])
                .select()
                .single();

            if (insertError) {
                console.error("Profile insert error:", insertError);
                throw new Error("Profile creation failed");
            }

            profile = insertedProfile;
            isNewUser = true;
        }

        const needsUsername = needsUsernameSetup(profile);

        sessions[state] = {
            id: userInfo.sub,
            email: userInfo.email,
            name: profile.name, // Use the preserved/updated name from database
            picture: userInfo.picture,
            suiWallet: profile.sui_address,
            authMethod: "zklogin",
            profileId: profile.id,
            sub: userInfo.sub,
            aud: userInfo.aud,
            needsUsernameSetup: needsUsername
        };

        try {
            console.log(`Checking Sui balance for zkLogin user...`);
            const balance = await suiClient.getBalance({
                owner: profile.sui_address,
                coinType: '0x2::sui::SUI'
            });
            const formattedBalance = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4);
            console.log(`Sui Balance: ${formattedBalance} SUI (${balance.totalBalance} MIST)`);
        } catch (balanceError) {
            console.log(`Could not fetch balance: ${balanceError.message} (This is normal for new addresses)`);
        }

        console.log(`zkLogin successful for ${userInfo.email} - ${isNewUser ? 'New user created' : 'Existing user logged in'}`);
        
        const welcomeMessage = isNewUser ?
            `Welcome to the game, ${profile.name}!` : // Use profile name, not Google name
            `Welcome back, ${profile.name}!`;

        res.send(`
            <html>
            <head>
                <title>Sign In Successful</title>
                <style>
                    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
                    .container { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; max-width: 500px; margin: 0 auto; }
                    .success { color: #4CAF50; font-size: 28px; margin-bottom: 20px; }
                    .info { color: #f0f0f0; margin: 15px 0; font-size: 16px; }
                    .wallet { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; word-break: break-all; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="success">Sign In Successful!</div>
                    <div class="info">${welcomeMessage}</div>
                    <div class="info">Your Sui Wallet:</div>
                    <div class="wallet">${profile.sui_address}</div>
                    <div class="info" style="margin-top: 20px;">You can now close this window and return to the game.</div>
                </div>
            </body>
            </html>
        `);

    } catch (err) {
        console.error("OAuth callback error:", err);
        res.status(500).send(`
            <html>
            <head>
                <title>Authentication Failed</title>
                <style>
                    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f44336; color: white; }
                </style>
            </head>
            <body>
                <h1>Authentication Failed</h1>
                <p>Error: ${err.message}</p>
                <p>Please close this window and try again.</p>
            </body>
            </html>
        `);
    }
});

// Unity polling endpoint
app.get("/getProfile", (req, res) => {
  const { state } = req.query;
  if (sessions[state]) {
    res.json(sessions[state]);
    delete sessions[state];
  } else {
    res.status(404).send("Not ready");
  }
});

// Health check
app.get("/ping", async (req, res) => {
  try {
    const chainId = await suiClient.getChainIdentifier();
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      network: NETWORK_CONFIG.current,
      chainId
    });
  } catch (err) {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Server is running",
      networkError: err.message
    });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
  console.log(`RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
});
