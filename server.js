// Enhanced server.js with better wallet standard support
import express from "express";
import bodyParser from "body-parser";
import fetch from "node-fetch";
import { jwtDecode } from "jwt-decode";
import { generateRandomness, jwtToAddress } from "@mysten/sui/zklogin";
import { isValidSuiAddress } from "@mysten/sui/utils";
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

import supabase from "./supabaseClient.js";
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';
import fs from 'fs';

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Network Configuration
const NETWORK_CONFIG = {
  current: process.env.SUI_NETWORK || 'testnet',
  devnet: 'https://fullnode.devnet.sui.io',
  testnet: 'https://fullnode.testnet.sui.io',
  mainnet: 'https://fullnode.mainnet.sui.io'
};

// Initialize Sui Client
const suiClient = new SuiClient({
  url: getFullnodeUrl(NETWORK_CONFIG.current)
});

console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()} network`);


// Enhanced CORS middleware with more specific headers
app.use((req, res, next) => {
  const origin = req.headers.origin;
  const allowedOrigins = [
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://your-game-domain.com' // Replace with your actual domain
  ];

  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  } else {
    res.header('Access-Control-Allow-Origin', '*');
  }
  
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, X-Wallet-Standard');
  res.header('Access-Control-Allow-Credentials', 'true');

  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

app.use(bodyParser.json());

// Enhanced request logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  
  // Log wallet standard specific headers
  if (req.headers['x-wallet-standard']) {
    console.log('Wallet Standard Request:', req.headers['x-wallet-standard']);
  }
  
  if (req.body && Object.keys(req.body).length > 0) {
    // Sanitize sensitive data for logging
    const logBody = { ...req.body };
    if (logBody.signature) {
      logBody.signature = '[SIGNATURE]';
    }
    console.log('Request Body:', JSON.stringify(logBody, null, 2));
  }
  next();
});

const PORT = process.env.PORT || 3000;
const sessions = {}; // { state: profile }

// Wallet type detection helper
// In your server.js
function detectWalletType(walletName, headers) {
    const standardWallets = ['sui wallet', 'suiet', 'ethos', 'martian', 'nightly', 'okx wallet'];
    
    // Check if wallet name indicates wallet standard compatibility
    if (headers['x-wallet-standard'] === 'true' || 
        (walletName && standardWallets.some(w => walletName.toLowerCase().includes(w)))) {
        return 'wallet_standard';
    }
    
    if (walletName === 'manual') {
        return 'manual_wallet';
    }
    
    return 'browser_wallet';
}

// Helper function to check if user needs username setup
function needsUsernameSetup(profile) {
  if (!profile || !profile.name) return true;
  const isAutoGenerated = profile.name.startsWith('Player_0x') && profile.name.length <= 16;
  return isAutoGenerated;
}

app.use(express.static(path.join(__dirname, 'public')));


// Enhanced wallet connect route with better error handling
app.get("/wallet-connect", (req, res) => {
  const { state } = req.query;

  if (!state) {
    return res.status(400).send("Missing state parameter");
  }

  // Read the enhanced HTML file
  const htmlPath = path.join(__dirname, 'enhanced-wallet-connect.html');
  
  fs.readFile(htmlPath, 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading enhanced HTML file:', err);
      
      // Fallback to original file
      const fallbackPath = path.join(__dirname, 'wallet-connect.html');
      fs.readFile(fallbackPath, 'utf8', (fallbackErr, fallbackData) => {
        if (fallbackErr) {
          console.error('Error reading fallback HTML file:', fallbackErr);
          return res.status(500).send('Server error');
        }
        
        const htmlWithState = fallbackData.replace('{{STATE}}', state);
        res.send(htmlWithState);
      });
      return;
    }
    
    // Replace placeholder with actual state
    const htmlWithState = data.replace('{{STATE}}', state);
    res.send(htmlWithState);
  });
});

// Enhanced browser wallet authentication endpoint
app.post("/auth/browser-wallet", async (req, res) => {
  console.log("ðŸ”— Enhanced browser wallet connection request received");
  console.log("Request headers:", req.headers);
  
  try {
    const {
      walletAddress,
      signature,
      message,
      walletName,
      state,
      publicKey,
      walletFeatures // New: Features supported by the wallet
    } = req.body;

    // Basic validation
    if (!walletAddress) {
      console.log("âŒ Missing wallet address");
      return res.status(400).json({
        success: false,
        error: "Missing wallet address"
      });
    }

    if (!state) {
      console.log("âŒ Missing state parameter");
      return res.status(400).json({
        success: false,
        error: "Missing state parameter"
      });
    }

    // Validate Sui address format
    if (!isValidSuiAddress(walletAddress)) {
      console.log("âŒ Invalid address format:", walletAddress);
      return res.status(400).json({
        success: false,
        error: "Invalid Sui address format"
      });
    }

    const walletType = detectWalletType(walletName, req.headers);
    console.log(`âœ… Valid wallet address: ${walletAddress}`);
    console.log(`ðŸ”— Wallet connecting: ${walletName || 'Unknown'} (${walletType}) - ${walletAddress}`);

    // Enhanced blockchain status check
    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      network: NETWORK_CONFIG.current,
      error: null,
      objectCount: 0
    };

    try {
      console.log('ðŸ”— Checking enhanced blockchain status...');

      // Parallel requests for better performance
      const [balanceResult, objectsResult] = await Promise.allSettled([
        suiClient.getBalance({
          owner: walletAddress,
          coinType: '0x2::sui::SUI'
        }),
        suiClient.getOwnedObjects({
          owner: walletAddress,
          limit: 10 // Get more objects for better activity detection
        })
      ]);

      const balance = balanceResult.status === 'fulfilled' ? balanceResult.value : null;
      const objects = objectsResult.status === 'fulfilled' ? objectsResult.value : null;

      if (balance) {
        blockchainInfo.exists = true;
        blockchainInfo.balance = balance.totalBalance;
        blockchainInfo.balanceFormatted = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI';
      }

      if (objects) {
        blockchainInfo.objectCount = objects.data.length;
        blockchainInfo.hasActivity = parseInt(blockchainInfo.balance || '0') > 0 || objects.data.length > 0;
      }

      console.log(`âœ… Enhanced blockchain info:`, blockchainInfo);

    } catch (blockchainError) {
      console.log(`âš ï¸ Blockchain check failed: ${blockchainError.message}`);
      blockchainInfo.error = blockchainError.message;
    }

    // Check if user already exists
    let { data: existingProfile, error: queryError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("sui_address", walletAddress)
      .single();

    if (queryError && queryError.code !== 'PGRST116') {
      console.error("âŒ Database query error:", queryError);
      return res.status(500).json({
        success: false,
        error: "Database query failed"
      });
    }

    let finalProfile;
    let isNewUser = false;

    if (existingProfile) {
      console.log("âœ… Found existing user profile:", existingProfile.id);

      // Update existing profile with enhanced info
      const updateData = {
        updated_at: new Date().toISOString(),
        auth_method: walletType,
        last_wallet_name: walletName
      };

      // Store wallet features if provided
      if (walletFeatures) {
        updateData.wallet_features = JSON.stringify(walletFeatures);
      }

      const { data: updated, error: updateError } = await supabase
        .from("user_profiles")
        .update(updateData)
        .eq("id", existingProfile.id)
        .select()
        .single();

      if (updateError) {
        console.error("âŒ Profile update error:", updateError);
        return res.status(500).json({
          success: false,
          error: "Profile update failed"
        });
      }

      finalProfile = updated;
      console.log("âœ… Existing user profile updated with enhanced data");
    } else {
      console.log("ðŸ†• Creating new user profile with enhanced data");

      const tempName = `Player_${walletAddress.substring(0, 8)}`;

      const profileData = {
        email: null,
        google_id: null,
        name: tempName,
        picture: null,
        user_salt: null,
        sui_address: walletAddress,
        auth_method: walletType,
        last_wallet_name: walletName,
        wallet_features: walletFeatures ? JSON.stringify(walletFeatures) : null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const { data: inserted, error: insertError } = await supabase
        .from("user_profiles")
        .insert([profileData])
        .select()
        .single();

      if (insertError) {
        console.error("âŒ Profile insert error:", insertError);
        return res.status(500).json({
          success: false,
          error: "Profile creation failed: " + insertError.message
        });
      }

      finalProfile = inserted;
      isNewUser = true;
      console.log("âœ… New user profile created with enhanced data:", finalProfile.id);
    }

    const needsUsername = needsUsernameSetup(finalProfile);
    console.log(`Username setup needed: ${needsUsername}`);

    // Enhanced session data with wallet standard info
    const sessionData = {
      id: finalProfile.id,
      email: finalProfile.email,
      name: finalProfile.name,
      picture: finalProfile.picture,
      suiWallet: walletAddress,
      authMethod: walletType,
      walletName: walletName,
      profileId: finalProfile.id,
      needsUsernameSetup: needsUsername,
      walletStandard: walletType === 'wallet_standard',
      publicKey: publicKey || null
    };

    // Store session for Unity polling
    sessions[state] = sessionData;
    console.log("âœ… Enhanced session stored with state:", state);

    // Enhanced response with wallet standard info
    const responseData = {
      success: true,
      message: isNewUser ? "New wallet connected successfully" : "Wallet reconnected successfully",
      needsUsernameSetup: needsUsername,
      walletStandard: walletType === 'wallet_standard',
      blockchain: {
        verified: blockchainInfo.exists,
        balance: blockchainInfo.balance,
        balanceFormatted: blockchainInfo.balanceFormatted,
        objectCount: blockchainInfo.objectCount,
        network: blockchainInfo.network,
        error: blockchainInfo.error
      },
      profile: {
        id: finalProfile.id,
        name: finalProfile.name,
        suiWallet: walletAddress,
        authMethod: walletType,
        walletName: walletName,
        profileId: finalProfile.id,
        needsUsernameSetup: needsUsername
      }
    };

    console.log("âœ… Sending enhanced success response");
    res.json(responseData);

  } catch (err) {
    console.error("âŒ Enhanced browser wallet connection error:", err);
    res.status(500).json({
      success: false,
      error: "Wallet connection failed: " + err.message
    });
  }
});

// Enhanced wallet validation with standard support
app.post("/validate-wallet", async (req, res) => {
  console.log("ðŸ” Enhanced wallet validation request received");
  
  try {
    const { address, walletName, features } = req.body;

    if (!address) {
      console.log("âŒ No address provided");
      return res.status(400).json({
        valid: false,
        address: null,
        message: "No wallet address provided"
      });
    }

    const cleanAddress = address.trim();
    const walletType = detectWalletType(walletName, req.headers);
    
    console.log(`ðŸ” Validating address: ${cleanAddress} (${walletType})`);

    const isValidFormat = isValidSuiAddress(cleanAddress);
    console.log(`Address format validation: ${isValidFormat}`);

    let blockchainInfo = {
      exists: false,
      balance: '0',
      hasActivity: false,
      error: null,
      objectCount: 0
    };

    if (isValidFormat) {
      try {
        console.log('ðŸ”— Checking enhanced blockchain status...');

        const [balanceResult, objectsResult] = await Promise.allSettled([
          suiClient.getBalance({
            owner: cleanAddress,
            coinType: '0x2::sui::SUI'
          }),
          suiClient.getOwnedObjects({
            owner: cleanAddress,
            limit: 5
          })
        ]);

        if (balanceResult.status === 'fulfilled') {
          const balance = balanceResult.value;
          blockchainInfo.exists = true;
          blockchainInfo.balance = balance.totalBalance;
          blockchainInfo.balanceFormatted = (parseInt(balance.totalBalance) / 1_000_000_000).toFixed(4) + ' SUI';
        }

        if (objectsResult.status === 'fulfilled') {
          const objects = objectsResult.value;
          blockchainInfo.objectCount = objects.data.length;
          blockchainInfo.hasActivity = parseInt(blockchainInfo.balance || '0') > 0 || objects.data.length > 0;
        }

        console.log(`âœ… Enhanced blockchain info:`, blockchainInfo);

      } catch (blockchainError) {
        console.log(`âš ï¸ Blockchain check failed: ${blockchainError.message}`);
        blockchainInfo.error = blockchainError.message;
      }
    }

    const responseData = {
      valid: isValidFormat,
      address: cleanAddress,
      walletType: walletType,
      walletStandard: walletType === 'wallet_standard',
      message: isValidFormat
        ? (blockchainInfo.exists
          ? `Valid Sui address (Balance: ${blockchainInfo.balanceFormatted}, Objects: ${blockchainInfo.objectCount})`
          : 'Valid Sui address (Not yet active on blockchain)')
        : "Invalid Sui address format",
      blockchain: blockchainInfo,
      network: NETWORK_CONFIG.current,
      features: features || null
    };

    console.log("Sending enhanced validation response:", responseData);
    res.json(responseData);

  } catch (err) {
    console.error("Enhanced validation error:", err);
    res.status(500).json({
      valid: false,
      address: req.body?.address || null,
      message: "Server error during validation: " + err.message
    });
  }
});

// Enhanced username setup endpoint
app.post("/setup-username", async (req, res) => {
  const { walletAddress, username } = req.body;

  try {
    if (!walletAddress || !username) {
      return res.status(400).json({
        success: false,
        error: "Wallet address and username are required"
      });
    }

    const trimmedUsername = username.trim();

    // Enhanced username validation
    if (trimmedUsername.length < 3 || trimmedUsername.length > 20) {
      return res.status(400).json({
        success: false,
        error: "Username must be between 3 and 20 characters"
      });
    }

    if (!/^[a-zA-Z0-9_-]+$/.test(trimmedUsername)) {
      return res.status(400).json({
        success: false,
        error: "Username can only contain letters, numbers, underscore, and hyphen"
      });
    }

    // Check for reserved usernames
    const reservedUsernames = ['admin', 'root', 'system', 'api', 'wallet', 'sui'];
    if (reservedUsernames.includes(trimmedUsername.toLowerCase())) {
      return res.status(400).json({
        success: false,
        error: "Username is reserved"
      });
    }

    // Check if username is already taken
    const { data: existingUser, error: checkError } = await supabase
      .from("user_profiles")
      .select("id")
      .eq("name", trimmedUsername)
      .neq("sui_address", walletAddress)
      .single();

    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: "Username already taken"
      });
    }

    // Update username
    const { data: updatedProfile, error: updateError } = await supabase
      .from("user_profiles")
      .update({
        name: trimmedUsername,
        updated_at: new Date().toISOString()
      })
      .eq("sui_address", walletAddress)
      .select()
      .single();

    if (updateError) {
      console.error("Username update error:", updateError);
      return res.status(500).json({
        success: false,
        error: "Failed to update username"
      });
    }

    res.json({
      success: true,
      message: "Username updated successfully",
      profile: {
        id: updatedProfile.id,
        name: updatedProfile.name,
        suiWallet: updatedProfile.sui_address,
        authMethod: updatedProfile.auth_method,
        profileId: updatedProfile.id,
        needsUsernameSetup: false
      }
    });

  } catch (err) {
    console.error("Username setup error:", err);
    res.status(500).json({
      success: false,
      error: "Username setup failed: " + err.message
    });
  }
});

// Rest of your existing endpoints remain the same...
// (Google OAuth callback, Unity polling, health check, etc.)

// Google OAuth callback (unchanged from your original)
app.get("/auth/google/callback", async (req, res) => {
  // ... your existing Google OAuth code remains the same
});

// Unity polling endpoint (unchanged)
app.get("/getProfile", (req, res) => {
  const { state } = req.query;
  if (sessions[state]) {
    res.json(sessions[state]);
    delete sessions[state];
  } else {
    res.status(404).send("Not ready");
  }
});

// Enhanced health check
app.get("/ping", async (req, res) => {
  try {
    const chainId = await suiClient.getChainIdentifier();
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "Enhanced server with Wallet Standard support is running",
      network: NETWORK_CONFIG.current,
      chainId,
      walletStandardSupported: true
    });
  } catch (err) {
    res.json({
      status: "ok", 
      timestamp: new Date().toISOString(),
      message: "Enhanced server is running",
      networkError: err.message,
      walletStandardSupported: true
    });
  }
});

app.listen(PORT, () => {
  console.log(`Enhanced server with Wallet Standard support running on port ${PORT}`);
  console.log(`Connected to Sui ${NETWORK_CONFIG.current.toUpperCase()}`);
  console.log(`RPC URL: ${getFullnodeUrl(NETWORK_CONFIG.current)}`);
  console.log(`Wallet Standard API: Enabled`);
});