<!DOCTYPE html>
<html>
<head>
    <title>Wallet Extension Key Scanner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Monaco', 'Consolas', monospace;
            background: #0d1117;
            color: #e6edf3;
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }
        .header {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            color: white;
            font-size: 24px;
        }
        .scanner-controls {
            background: #21262d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #30363d;
        }
        .results-section {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            margin: 15px 0;
        }
        .section-header {
            background: #21262d;
            padding: 15px;
            border-bottom: 1px solid #30363d;
            font-weight: bold;
            color: #58a6ff;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }
        .section-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        .collapsed .section-content {
            display: none;
        }
        .scan-button {
            background: #238636;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .scan-button:hover {
            background: #2ea043;
        }
        .scan-button:disabled {
            background: #656d76;
            cursor: not-allowed;
        }
        .wallet-key {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'SF Mono', Monaco, monospace;
        }
        .key-name {
            color: #f85149;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .key-path {
            color: #79c0ff;
            font-size: 12px;
        }
        .key-type {
            color: #a5a5a5;
            font-size: 11px;
            margin-top: 5px;
        }
        .method-list {
            color: #7ee787;
            font-size: 11px;
            margin-top: 5px;
            max-height: 100px;
            overflow-y: auto;
        }
        .sui-indicator {
            background: #f85149;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 8px;
        }
        .code-block {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        .copy-button {
            float: right;
            background: #21262d;
            color: #e6edf3;
            border: 1px solid #30363d;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .copy-button:hover {
            background: #30363d;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            background: #1c2128;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            text-align: center;
        }
        .stat-item {
            flex: 1;
        }
        .stat-number {
            font-size: 24px;
            color: #58a6ff;
            font-weight: bold;
        }
        .stat-label {
            font-size: 12px;
            color: #8b949e;
            margin-top: 5px;
        }
        .filter-controls {
            margin: 15px 0;
        }
        .filter-button {
            background: #21262d;
            color: #e6edf3;
            border: 1px solid #30363d;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        .filter-button.active {
            background: #58a6ff;
            color: #0d1117;
        }
        .search-box {
            width: 100%;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 8px;
            border-radius: 4px;
            font-family: inherit;
            margin: 10px 0;
        }
        .search-box:focus {
            outline: none;
            border-color: #58a6ff;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Wallet Extension Key Scanner</h1>
        <p>Automatically discover all wallet-related window properties and methods</p>
    </div>
    
    <div class="scanner-controls">
        <button class="scan-button" onclick="scanAllWallets()" id="scanBtn">
            üöÄ Scan for All Wallets
        </button>
        <button class="scan-button" onclick="deepScanWindow()" id="deepScanBtn">
            üî¨ Deep Window Scan
        </button>
        <button class="scan-button" onclick="generateIntegrationCode()" id="generateBtn">
            üìÑ Generate Integration Code
        </button>
        <button class="scan-button" onclick="exportKeys()" id="exportBtn">
            üíæ Export Keys
        </button>
        
        <div class="stats" id="statsContainer">
            <div class="stat-item">
                <div class="stat-number" id="totalKeys">0</div>
                <div class="stat-label">Total Keys Found</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="suiWallets">0</div>
                <div class="stat-label">Sui Wallets</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="allWallets">0</div>
                <div class="stat-label">All Wallets</div>
            </div>
        </div>
        
        <input type="text" class="search-box" id="searchBox" placeholder="Search keys..." onkeyup="filterResults()">
        
        <div class="filter-controls">
            <button class="filter-button active" onclick="setFilter('all')">All</button>
            <button class="filter-button" onclick="setFilter('sui')">Sui Only</button>
            <button class="filter-button" onclick="setFilter('wallet')">Wallets Only</button>
            <button class="filter-button" onclick="setFilter('methods')">With Methods</button>
        </div>
    </div>

    <div class="results-section" id="foundKeysSection">
        <div class="section-header" onclick="toggleSection('foundKeysSection')">
            <span>üîë Discovered Wallet Keys</span>
            <span id="foundKeysCount">0 keys</span>
        </div>
        <div class="section-content">
            <div id="foundKeysResults">
                Click "Scan for All Wallets" to discover wallet keys
            </div>
        </div>
    </div>

    <div class="results-section" id="integrationCodeSection">
        <div class="section-header" onclick="toggleSection('integrationCodeSection')">
            <span>üìù Integration Code</span>
            <button class="copy-button" onclick="copyIntegrationCode()">Copy</button>
        </div>
        <div class="section-content">
            <div class="code-block" id="integrationCodeResults">
                Integration code will appear here after scanning
            </div>
        </div>
    </div>

    <div class="results-section" id="rawDataSection">
        <div class="section-header" onclick="toggleSection('rawDataSection')">
            <span>üîç Raw Detection Data</span>
            <button class="copy-button" onclick="copyRawData()">Copy</button>
        </div>
        <div class="section-content collapsed">
            <div class="code-block" id="rawDataResults">
                Raw data will appear here after scanning
            </div>
        </div>
    </div>

    <script>
        let discoveredKeys = new Map();
        let currentFilter = 'all';
        let rawScanData = {};

        function scanAllWallets() {
            const scanBtn = document.getElementById('scanBtn');
            scanBtn.disabled = true;
            scanBtn.textContent = 'üîÑ Scanning...';
            
            discoveredKeys.clear();
            rawScanData = {
                timestamp: new Date().toISOString(),
                windowKeys: {},
                walletObjects: {},
                suspiciousObjects: {}
            };
            
            console.log('üöÄ Starting comprehensive wallet key scan');
            
            // Phase 1: Scan all window properties
            scanWindowProperties();
            
            // Phase 2: Deep scan suspicious objects
            deepScanSuspiciousObjects();
            
            // Phase 3: Pattern-based detection
            patternBasedDetection();
            
            // Update UI
            updateResults();
            updateStats();
            generateIntegrationCode();
            
            scanBtn.disabled = false;
            scanBtn.textContent = 'üöÄ Scan for All Wallets';
            
            console.log(`‚úÖ Scan complete: ${discoveredKeys.size} keys discovered`);
        }

        function scanWindowProperties() {
            console.log('üì° Phase 1: Scanning window properties');
            
            const windowProps = Object.getOwnPropertyNames(window);
            console.log(`Found ${windowProps.length} window properties to analyze`);
            
            for (const prop of windowProps) {
                try {
                    const obj = window[prop];
                    if (!obj || typeof obj !== 'object') continue;
                    
                    const analysis = analyzeObject(obj, prop);
                    if (analysis.isWalletLike || analysis.isSui || analysis.hasWalletMethods) {
                        discoveredKeys.set(prop, {
                            path: `window.${prop}`,
                            object: obj,
                            analysis: analysis,
                            discovered: 'window_scan'
                        });
                        
                        rawScanData.windowKeys[prop] = {
                            type: typeof obj,
                            analysis: analysis,
                            methods: analysis.methods,
                            properties: analysis.properties
                        };
                        
                        console.log(`üîç Found wallet-like: window.${prop}`);
                    }
                } catch (error) {
                    // Skip inaccessible properties
                    continue;
                }
            }
        }

        function deepScanSuspiciousObjects() {
            console.log('üî¨ Phase 2: Deep scanning suspicious objects');
            
            // Scan nested properties of discovered objects
            discoveredKeys.forEach((data, key) => {
                try {
                    const obj = data.object;
                    scanNestedProperties(obj, key, 2); // max depth 2
                } catch (error) {
                    console.warn(`Failed to deep scan ${key}:`, error.message);
                }
            });
        }

        function scanNestedProperties(obj, parentKey, maxDepth, currentDepth = 0) {
            if (currentDepth >= maxDepth || !obj || typeof obj !== 'object') return;
            
            for (const prop of Object.getOwnPropertyNames(obj)) {
                try {
                    const nestedObj = obj[prop];
                    if (!nestedObj || typeof nestedObj !== 'object') continue;
                    
                    const nestedPath = `${parentKey}.${prop}`;
                    const analysis = analyzeObject(nestedObj, nestedPath);
                    
                    if (analysis.isSui || analysis.hasWalletMethods) {
                        const fullPath = `window.${nestedPath}`;
                        discoveredKeys.set(fullPath, {
                            path: fullPath,
                            object: nestedObj,
                            analysis: analysis,
                            discovered: 'deep_scan',
                            parent: parentKey
                        });
                        
                        console.log(`üîç Found nested wallet: ${fullPath}`);
                    }
                    
                    // Recursive scan
                    scanNestedProperties(nestedObj, nestedPath, maxDepth, currentDepth + 1);
                    
                } catch (error) {
                    continue;
                }
            }
        }

        function patternBasedDetection() {
            console.log('üéØ Phase 3: Pattern-based detection');
            
            // Common wallet patterns
            const walletPatterns = [
                /wallet/i,
                /sui/i,
                /ethereum/i,
                /solana/i,
                /phantom/i,
                /metamask/i,
                /coinbase/i,
                /trust/i,
                /ledger/i,
                /trezor/i
            ];
            
            // Scan for pattern matches
            for (const prop of Object.getOwnPropertyNames(window)) {
                if (walletPatterns.some(pattern => pattern.test(prop))) {
                    try {
                        const obj = window[prop];
                        if (obj && typeof obj === 'object' && !discoveredKeys.has(prop)) {
                            const analysis = analyzeObject(obj, prop);
                            if (analysis.score > 2) { // Minimum score threshold
                                discoveredKeys.set(prop, {
                                    path: `window.${prop}`,
                                    object: obj,
                                    analysis: analysis,
                                    discovered: 'pattern_match'
                                });
                                
                                console.log(`üéØ Pattern match: window.${prop}`);
                            }
                        }
                    } catch (error) {
                        continue;
                    }
                }
            }
        }

        function analyzeObject(obj, path) {
            const analysis = {
                methods: [],
                properties: [],
                nestedObjects: [],
                isWalletLike: false,
                isSui: false,
                hasWalletMethods: false,
                score: 0,
                chains: [],
                features: []
            };
            
            try {
                // Get methods and properties
                const allProps = Object.getOwnPropertyNames(obj);
                const prototypeProps = obj.constructor && obj.constructor.prototype ? 
                    Object.getOwnPropertyNames(obj.constructor.prototype) : [];
                
                const combinedProps = [...new Set([...allProps, ...prototypeProps])];
                
                for (const prop of combinedProps) {
                    try {
                        const value = obj[prop];
                        if (typeof value === 'function') {
                            analysis.methods.push(prop);
                        } else if (value && typeof value === 'object') {
                            analysis.nestedObjects.push(prop);
                        } else {
                            analysis.properties.push(prop);
                        }
                    } catch (e) {
                        // Skip inaccessible properties
                        continue;
                    }
                }
                
                // Analyze for wallet characteristics
                const walletMethods = [
                    'connect', 'disconnect', 'getAccounts', 'getAccount',
                    'signTransaction', 'signAndExecuteTransaction', 
                    'signAndExecuteTransactionBlock', 'signTransactionBlock',
                    'requestPermissions', 'enable', 'send', 'signMessage',
                    'signAndSubmitTransaction'
                ];
                
                const suiMethods = [
                    'signAndExecuteTransactionBlock', 'signTransactionBlock',
                    'getAccounts', 'requestPermissions'
                ];
                
                const walletProps = [
                    'isConnected', 'connected', 'account', 'accounts',
                    'address', 'publicKey', 'chainId', 'networkId'
                ];
                
                // Score based on wallet methods
                const foundWalletMethods = walletMethods.filter(method => 
                    analysis.methods.includes(method)
                );
                analysis.hasWalletMethods = foundWalletMethods.length > 0;
                analysis.score += foundWalletMethods.length * 2;
                
                // Score based on Sui methods
                const foundSuiMethods = suiMethods.filter(method => 
                    analysis.methods.includes(method)
                );
                analysis.isSui = foundSuiMethods.length > 0 || 
                                path.toLowerCase().includes('sui') ||
                                analysis.nestedObjects.includes('sui');
                if (analysis.isSui) analysis.score += 5;
                
                // Score based on wallet properties
                const foundWalletProps = walletProps.filter(prop => 
                    analysis.properties.includes(prop)
                );
                analysis.score += foundWalletProps.length;
                
                // Check for nested wallet objects
                for (const nestedProp of analysis.nestedObjects) {
                    try {
                        const nestedObj = obj[nestedProp];
                        if (nestedObj && typeof nestedObj === 'object') {
                            // Check if nested object has wallet methods
                            const nestedMethods = Object.getOwnPropertyNames(nestedObj)
                                .filter(prop => typeof nestedObj[prop] === 'function');
                            
                            const hasNestedWalletMethods = walletMethods
                                .some(method => nestedMethods.includes(method));
                            
                            if (hasNestedWalletMethods) {
                                analysis.score += 3;
                                if (nestedProp.toLowerCase().includes('sui')) {
                                    analysis.isSui = true;
                                    analysis.score += 5;
                                }
                            }
                            
                            // Check for chains array
                            if (nestedObj.chains && Array.isArray(nestedObj.chains)) {
                                analysis.chains = nestedObj.chains;
                                if (nestedObj.chains.some(chain => 
                                    chain.toLowerCase().includes('sui'))) {
                                    analysis.isSui = true;
                                    analysis.score += 5;
                                }
                            }
                            
                            // Check for features object
                            if (nestedObj.features && typeof nestedObj.features === 'object') {
                                analysis.features = Object.keys(nestedObj.features);
                                if (analysis.features.some(feature => 
                                    feature.startsWith('sui:'))) {
                                    analysis.isSui = true;
                                    analysis.score += 5;
                                }
                            }
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                // Determine if wallet-like
                analysis.isWalletLike = analysis.score >= 3 || 
                                      analysis.hasWalletMethods ||
                                      path.toLowerCase().includes('wallet');
                
            } catch (error) {
                console.warn(`Analysis failed for ${path}:`, error.message);
            }
            
            return analysis;
        }

        function updateResults() {
            const container = document.getElementById('foundKeysResults');
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            
            const filteredKeys = Array.from(discoveredKeys.entries()).filter(([key, data]) => {
                const matchesSearch = !searchTerm || 
                    key.toLowerCase().includes(searchTerm) ||
                    data.path.toLowerCase().includes(searchTerm);
                
                const matchesFilter = 
                    currentFilter === 'all' ||
                    (currentFilter === 'sui' && data.analysis.isSui) ||
                    (currentFilter === 'wallet' && data.analysis.isWalletLike) ||
                    (currentFilter === 'methods' && data.analysis.hasWalletMethods);
                
                return matchesSearch && matchesFilter;
            });
            
            if (filteredKeys.length === 0) {
                container.innerHTML = '<p>No wallet keys found. Try scanning first.</p>';
                return;
            }
            
            const html = filteredKeys.map(([key, data]) => {
                const { analysis, path, discovered } = data;
                
                return `
                    <div class="wallet-key">
                        <div class="key-name">
                            ${key}
                            ${analysis.isSui ? '<span class="sui-indicator">SUI</span>' : ''}
                        </div>
                        <div class="key-path">${path}</div>
                        <div class="key-type">
                            Discovery: ${discovered} | Score: ${analysis.score} | 
                            Methods: ${analysis.methods.length} | 
                            Properties: ${analysis.properties.length}
                        </div>
                        ${analysis.methods.length > 0 ? `
                            <div class="method-list">
                                Methods: ${analysis.methods.slice(0, 10).join(', ')}
                                ${analysis.methods.length > 10 ? '...' : ''}
                            </div>
                        ` : ''}
                        ${analysis.chains.length > 0 ? `
                            <div class="method-list">
                                Chains: ${analysis.chains.join(', ')}
                            </div>
                        ` : ''}
                        ${analysis.features.length > 0 ? `
                            <div class="method-list">
                                Features: ${analysis.features.slice(0, 5).join(', ')}
                                ${analysis.features.length > 5 ? '...' : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            container.innerHTML = html;
            
            // Update count
            document.getElementById('foundKeysCount').textContent = `${filteredKeys.length} keys`;
        }

        function updateStats() {
            const totalKeys = discoveredKeys.size;
            const suiWallets = Array.from(discoveredKeys.values())
                .filter(data => data.analysis.isSui).length;
            const allWallets = Array.from(discoveredKeys.values())
                .filter(data => data.analysis.isWalletLike).length;
            
            document.getElementById('totalKeys').textContent = totalKeys;
            document.getElementById('suiWallets').textContent = suiWallets;
            document.getElementById('allWallets').textContent = allWallets;
        }

        function generateIntegrationCode() {
            const suiWallets = Array.from(discoveredKeys.entries())
                .filter(([key, data]) => data.analysis.isSui);
            
            if (suiWallets.length === 0) {
                document.getElementById('integrationCodeResults').textContent = 
                    'No Sui wallets found to generate integration code';
                return;
            }
            
            let code = `// Auto-generated Sui wallet configuration
// Generated on: ${new Date().toISOString()}
// Found ${suiWallets.length} Sui wallet(s)

const SUI_WALLET_CONFIGS = {\n`;
            
            suiWallets.forEach(([key, data], index) => {
                const configName = key.toLowerCase().replace(/[^a-z0-9]/g, '_');
                const { analysis } = data;
                
                code += `    ${configName}: {
        name: '${key.charAt(0).toUpperCase() + key.slice(1)} Wallet',
        windowKeys: ['${key}'],
        detectionPath: '${data.path}',
        methods: [${analysis.methods.map(m => `'${m}'`).join(', ')}],
        score: ${analysis.score},
        discovered: '${data.discovered}'`;
                
                if (analysis.chains.length > 0) {
                    code += `,
        chains: [${analysis.chains.map(c => `'${c}'`).join(', ')}]`;
                }
                
                if (analysis.features.length > 0) {
                    code += `,
        features: [${analysis.features.map(f => `'${f}'`).join(', ')}]`;
                }
                
                code += `\n    }${index < suiWallets.length - 1 ? ',' : ''}\n`;
            });
            
            code += `};

// Detection function
function detectSuiWallets() {
    const foundWallets = new Map();
    
    for (const [configKey, config] of Object.entries(SUI_WALLET_CONFIGS)) {
        for (const windowKey of config.windowKeys) {
            if (window[windowKey] && typeof window[windowKey] === 'object') {
                foundWallets.set(config.name, {
                    ...config,
                    wallet: window[windowKey],
                    windowKey: windowKey
                });
                console.log(\`‚úÖ Found \${config.name} via window.\${windowKey}\`);
                break;
            }
        }
    }
    
    return foundWallets;
}

// Usage example
const wallets = detectSuiWallets();
console.log(\`Found \${wallets.size} Sui wallets:\`, Array.from(wallets.keys()));`;
            
            document.getElementById('integrationCodeResults').textContent = code;
        }

        function deepScanWindow() {
            const deepBtn = document.getElementById('deepScanBtn');
            deepBtn.disabled = true;
            deepBtn.textContent = 'üîÑ Deep Scanning...';
            
            console.log('üî¨ Starting deep window scan');
            
            // Enhanced deep scan
            const allObjects = [];
            
            function collectAllObjects(obj, path = 'window', depth = 0, maxDepth = 3) {
                if (depth > maxDepth || !obj || typeof obj !== 'object') return;
                
                try {
                    const props = Object.getOwnPropertyNames(obj);
                    for (const prop of props) {
                        try {
                            const value = obj[prop];
                            const currentPath = `${path}.${prop}`;
                            
                            if (value && typeof value === 'object') {
                                const analysis = analyzeObject(value, currentPath);
                                if (analysis.score > 1) {
                                    allObjects.push({
                                        path: currentPath,
                                        object: value,
                                        analysis: analysis,
                                        depth: depth
                                    });
                                }
                                
                                if (depth < maxDepth) {
                                    collectAllObjects(value, currentPath, depth + 1, maxDepth);
                                }
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                } catch (e) {
                    console.warn(`Deep scan failed for ${path}:`, e.message);
                }
            }
            
            collectAllObjects(window);
            
            // Add all found objects to discovered keys
            allObjects.forEach(obj => {
                if (!discoveredKeys.has(obj.path)) {
                    discoveredKeys.set(obj.path, {
                        ...obj,
                        discovered: 'deep_scan'
                    });
                }
            });
            
            updateResults();
            updateStats();
            generateIntegrationCode();
            
            deepBtn.disabled = false;
            deepBtn.textContent = 'üî¨ Deep Window Scan';
            
            console.log(`üî¨ Deep scan complete: ${allObjects.length} additional objects found`);
        }

        function setFilter(filterType) {
            currentFilter = filterType;
            
            // Update button states
            document.querySelectorAll('.filter-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateResults();
        }

        function filterResults() {
            updateResults();
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('collapsed');
        }

        function copyIntegrationCode() {
            const code = document.getElementById('integrationCodeResults').textContent;
            navigator.clipboard.writeText(code).then(() => {
                console.log('Integration code copied to clipboard');
            });
        }

        function copyRawData() {
            const data = JSON.stringify(rawScanData, null, 2);
            navigator.clipboard.writeText(data).then(() => {
                console.log('Raw data copied to clipboard');
            });
        }

        function exportKeys() {
            const exportData = {
                timestamp: new Date().toISOString(),
                discoveredKeys: Object.fromEntries(
                    Array.from(discoveredKeys.entries()).map(([key, data]) => [
                        key,
                        {
                            path: data.path,
                            analysis: data.analysis,
                            discovered: data.discovered
                        }
                    ])
                ),
                stats: {
                    totalKeys: discoveredKeys.size,
                    suiWallets: Array.from(discoveredKeys.values())
                        .filter(data => data.analysis.isSui).length,
                    allWallets: Array.from(discoveredKeys.values())
                        .filter(data => data.analysis.isWalletLike).length
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `wallet-keys-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Wallet keys exported');
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Wallet Key Scanner initialized');
            
            // Auto-scan after a short delay
            setTimeout(() => {
                console.log('Running initial scan...');
                scanAllWallets();
            }, 2000);
            
            // Update raw data display
            updateRawDataDisplay();
        });

        function updateRawDataDisplay() {
            const rawData = {
                windowProperties: Object.getOwnPropertyNames(window).length,
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                timestamp: new Date().toISOString()
            };
            
            document.getElementById('rawDataResults').textContent = 
                JSON.stringify(rawData, null, 2);
        }

        // Monitor for dynamic wallet injections
        const observer = new MutationObserver((mutations) => {
            let shouldRescan = false;
            
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach((node) => {
                        if (node.tagName === 'SCRIPT' && node.src && 
                            (node.src.includes('wallet') || 
                             node.src.includes('sui') || 
                             node.src.includes('chrome-extension'))) {
                            console.log(`New wallet script detected: ${node.src}`);
                            shouldRescan = true;
                        }
                    });
                }
            });
            
            if (shouldRescan) {
                console.log('Rescanning due to new wallet injection...');
                setTimeout(scanAllWallets, 3000);
            }
        });
        
        observer.observe(document.head, { childList: true, subtree: true });
        observer.observe(document.body, { childList: true, subtree: true });

        // Additional utility functions
        function getWalletConnectionMethods(walletObject) {
            const connectionMethods = [];
            const commonMethods = [
                'connect', 'disconnect', 'enable', 'request',
                'getAccounts', 'getAccount', 'requestPermissions'
            ];
            
            commonMethods.forEach(method => {
                if (typeof walletObject[method] === 'function') {
                    connectionMethods.push(method);
                }
            });
            
            return connectionMethods;
        }

        function testWalletConnection(walletKey) {
            console.log(`Testing connection for ${walletKey}...`);
            const walletData = discoveredKeys.get(walletKey);
            if (!walletData) return;
            
            const wallet = walletData.object;
            const connectionMethods = getWalletConnectionMethods(wallet);
            
            console.log(`Available connection methods: ${connectionMethods.join(', ')}`);
            
            // This is just for testing - don't actually connect
            return {
                walletKey,
                available: true,
                connectionMethods,
                canTest: connectionMethods.length > 0
            };
        }
    </script>
</body>
</html>